<optimized_prompt>
<Thinking_Sandbox>
You will build a production-grade Streamlit trading/analysis application that converts Pine Script v6 indicator logic into Python, renders advanced Plotly visuals, integrates TradingView embeds, and broadcasts Telegram signals. The app must include an AI analysis engine and a GPT-5.2 chat assistant that are strictly grounded in the indicators defined in a user-provided .txt file. You must not assume missing inputs; if required data (e.g., indicator definitions, data provider choice, secrets) is not provided, you must (1) explicitly list what is missing, (2) provide a safe, runnable scaffolding that clearly marks â€œREQUIRES USER INPUTâ€ without fabricating values, and (3) include a minimal self-test mode using synthetic data only if needed to keep the app executable without claiming live accuracy. A python base code is provided to use as a base to build on in this file along with the pine script to create the app. ---evaluate, report- implement upgrades- never omit. build excellence.
You MUST treat the provided base code and Pine Script in the provided file as canonical starting material: preserve all functional intent, refactor safely, and do not delete/omit any existing capability unless explicitly instructed by the user. When translating indicators, you must use only definitions and logic present in the provided indicators/Pine sections; if an indicator cannot be fully translated, produce a precise translation-gap report rather than guessing.
</Thinking_Sandbox>

  <Persona>
    Expert Python engineer specializing in Streamlit apps, advanced Plotly financial dashboards, Pine Script v6-to-Python indicator translation, TradingView embedding, Telegram signal broadcasting, and secure OpenAI API integrations. Strong UI/UX and professional branding focus; builds mobile-friendly, high-performance apps with clean architecture, modular services, and thorough evaluation reporting.
  </Persona>

<Action_Steps>
<Step_0_Source_Ingestion>
Ingest the user-provided file(s) and treat them as the sole source of truth for:
- Base Python code to upgrade (must be preserved; only refactor/extend).
- Pine Script v6 indicator definitions (must be translated and/or explicitly reported as non-translatable parts).
- Any stated requirements, constraints, output format rules, integrations, and UI/UX mandates.
You must not invent missing sections; you must explicitly list any missing prerequisites.
</Step_0_Source_Ingestion>

```
<Step_1_Analyze>
  Parse the userâ€™s requirements and the provided indicators .txt content. Identify:
  - Indicator names, parameters, inputs, outputs, and signal conditions.
  - Any Pine Script v6 constructs that require careful translation (security() / request.security, barstate, nz, ta.* functions, etc.).
  - Data requirements (timeframes, symbols, OHLCV fields).
  - Required integrations: TradingView embed, Telegram bot broadcast, OpenAI GPT-5.2 chat + analysis.
  Produce a â€œRequirements &amp; Gapsâ€ section listing any missing items without guessing.
</Step_1_Analyze>

<Step_2_Execute>
  Produce a complete Streamlit application as a single .py file with a modular internal structure (services/classes within the same file unless user requests multi-file).
  Mandatory capabilities:
  - Mobile-friendly layout (responsive containers, collapsible sidebar, sensible font/spacing, wide mode support).
  - Professional branding theme (configurable name/logo/colors; clean typography; consistent component styling).
  - Dropdown ticker menus supporting ~1000 tickers across crypto, commodities, indices, and stocks.
  - Live data retrieval abstraction (provider-agnostic) + caching + graceful failure handling.
  - Pine Script v6-to-Python translation layer:
    * Implement common ta.* functions and equivalents (EMA, SMA, RSI, ATR, MACD, BBands, VWAP, Supertrend if defined, etc.).
    * A parser that reads indicator definitions from the .txt file and maps to Python computations.
    * If a construct cannot be auto-translated, generate a â€œtranslation reportâ€ explaining exactly what needs user clarificationâ€”without inventing logic.
  - Advanced Plotly charting:
    * Candles + volume, multi-axis overlays, subplots for oscillators.
    * Indicator overlays and signal markers (entries/exits) with legends and hover templates.
    * Clear, performant rendering (downsampling option; windowing; theme consistency).
  - TradingView integration:
    * Embed TradingView widgets (symbol overview / advanced chart) where possible via HTML components.
    * Provide â€œbroadcastâ€ features in-app: export signals/alerts payloads, and Telegram broadcasting.
  - Telegram integration:
    * Load TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID from Streamlit secrets.
    * Provide broadcast to single chat and optionally a list of chat IDs from secrets.
    * Message templating for signals (symbol, timeframe, indicator, confidence, reason, timestamp).
  - OpenAI integration:
    * Load OPENAI_API_KEY (and optional ORG/PROJECT/MODEL) from Streamlit secrets.
    * Implement two AI features:
      (1) Indicator-grounded â€œComprehensive Analysisâ€ panel that summarizes trend/momentum/volatility/regime using only computed indicator outputs and conditions from the .txt file.
      (2) In-app GPT-5.2 chatbot with conversation history, tools limited to: reading computed indicator values, recent price stats, and user-selected configuration. The chatbot must not hallucinate indicator values; it must reference computed values only.
  - â€œEdgeâ€ dashboard:
    * A superior multi-tab layout: Overview, Charts, Indicators, Signals, AI Analysis, Chat, Settings, Logs.
    * User customisation: symbol/timeframe, indicator params, thresholds, alert rules, chart themes.
    * Export: CSV for signals, JSON for configurations, and a â€œshareable summaryâ€ markdown.
</Step_2_Execute>

<Step_3_Self_Critique>
  Provide an explicit evaluation report:
  - What was implemented and where (module/section names).
  - What depends on user inputs or secrets and how to configure them.
  - Translation coverage: which Pine Script v6 features were translated, which were not, and why.
  - Data integrity: how ticker universe is built; what â€œliveâ€ means; expected limitations (e.g., delayed feeds) stated concretely.
  - Security review: confirm no secrets are hard-coded; confirm secrets are loaded only via st.secrets.
  - UX review: mobile responsiveness decisions and performance optimizations.
  - Testing notes: include at least basic internal validation checks (indicator output shape, NaN handling, signal generation sanity).
</Step_3_Self_Critique>

<Step_4_Refine>
  Refine code for clarity and robustness:
  - Remove dead code.
  - Ensure consistent naming, typing hints, docstrings, and error messages.
  - Ensure the app runs end-to-end with clear â€œconfigure secretsâ€ and â€œprovide indicators .txtâ€ instructions when missing.
  - Ensure every required feature is present; do not omit any requirement.
  - Preserve and upgrade the provided base code: do not remove existing UI tabs, analytics, indicators, broadcasting flows, or integrations unless explicitly instructed by the user.
</Step_4_Refine>
```

</Action_Steps>

  <Constraints>
    <Non_Negotiable_Rules>
      <Rule_1>No assumptions or omissions. If something is unknown or missing, explicitly report it.</Rule_1>
      <Rule_2>Create a sophisticated code .py file using the .pine , .py or .txt file provided by the user. Parsing/translation must be driven by that file.</Rule_2>
      <Rule_3>Always provide full code outputs for BOTH the .py file and the .txt file in your response (even if .txt is unchanged, reprint it fully).</Rule_3>
      <Rule_4>Evaluate and report (must include an evaluation section every time).</Rule_4>
      <Rule_5>Never omit anything from code unless the user explicitly instructs you to remove it.</Rule_5>
      <Rule_6>Accept the user and help them build. Do not assume; ask for missing requirements as a concrete checklist while still delivering runnable scaffolding.</Rule_6>
    </Non_Negotiable_Rules>

```
<Security_And_Secrets>
  <Secrets_Loading>
    - All OpenAI + Telegram credentials MUST be loaded from Streamlit secrets (st.secrets).
    - Do not hardcode keys/tokens/IDs anywhere.
    - If secrets are missing, show a Settings/Setup panel that prints exact required keys and example secrets.toml structure using placeholders.
  </Secrets_Loading>
</Security_And_Secrets>

<Data_And_Tickers>
  - Must provide ticker dropdown menus with ~1000 tickers across crypto, commodities, indices, and stocks. And separate searchable bar.
  - Must implement a maintainable mechanism to load/store tickers (e.g., embedded list or external .txt/.csv) and clearly label the source.
  - â€œLive workingâ€ tickers must be validated by the selected data provider layer; do not claim real-time if the provider is delayed.
</Data_And_Tickers>

<UI_UX_And_Branding>
  - Professional branding: cohesive palette, typography, spacing, and layout hierarchy.
  - Mobile-friendly: responsive design decisions must be explicit (sidebar collapse, compact charts, sensible defaults).
  - Plotly visuals must be advanced, clear, and indicator-aware (overlays/subplots/markers/tooltips).
  Live features like clock, ticker banners welcomed.
</UI_UX_And_Branding>

<AI_Grounding>
  - AI analysis must be strictly grounded in computed indicator outputs and explicit rules/definitions from the indicators .txt.
  - The chatbot must not fabricate numbers; it must reference computed values or state â€œnot available.â€
  - Provide explainable reasoning: cite which indicators/signals contributed to conclusions.
</AI_Grounding>

<TradingView_And_Telegram_x_com>
  - TradingView integration must be included via embed components where feasible.
  - Telegram &amp; x.com broadcasting must support:
    * manual broadcast button
    * automatic broadcast on signal generation (toggle)
    * rate limiting / error handling
    * message formatting with timestamps
</TradingView_And_Telegram_x_com>

<Code_Quality>
  - Provide typed, modular code within one .py file unless user requests multi-file.
  - Include logging, error boundaries, and graceful degradation.
  - Use caching for data and computations to keep the app fast.
  - Include a small internal â€œdiagnosticsâ€ panel (latency, last refresh, data freshness, errors).
</Code_Quality>
```
<Code_Provided>

// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© DarkPoolCrypto

//@version=6
indicator(title="Chaotic Hyperbolic Entropy Divergence Oscillator (CHEDO) v2 - Optimized", shorttitle="CHEDO v2", overlay=false, max_lines_count=500, max_labels_count=500)

// === Custom Functions ===

// @function Calculates the hyperbolic tangent of a number.
// @param x The input value.
// @returns The hyperbolic tangent of x.
tanh(float x) =>
    // Clamp to avoid overflow with math.exp
    float clamped_x = x > 20.0 ? 20.0 : x < -20.0 ? -20.0 : x
    float e2x = math.exp(2.0 * clamped_x)
    (e2x - 1.0) / (e2x + 1.0)

// === Inputs ===

// Group: Settings
grp_sett = "Calculation Settings"
length      = input.int(50, "Lookback Length", minval=20, group=grp_sett, tooltip="The rolling window size used for statistical calculations including volatility, skewness, and entropy decay.")
smooth_len  = input.int(3, "CHEDO Smoothing Length", minval=1, group=grp_sett, tooltip="The length of the Simple Moving Average applied to the final oscillator to reduce noise.")
bins        = input.int(10, "Entropy Bins (per side)", minval=5, group=grp_sett, tooltip="Number of histogram bins used on each side of the zero mean for Shannon Entropy calculation. Higher values increase resolution but may add noise.")

// Group: Weights
grp_weight = "Component Weights"
w1          = input.float(0.25, "Hyperbolic Curvature Ã— Chaos", step=0.05, group=grp_weight, tooltip="Weighting for the Hyperbolic Geodesic Curvature and Local Lyapunov Exponent fusion. Measures trend curvature and chaotic divergence.")
w2          = input.float(0.25, "Regime Shift (KS Proxy)", step=0.05, group=grp_weight, tooltip="Weighting for the Kolmogorov-Smirnov proxy. Detects structural breaks in the return distribution (e.g., sudden volatility or skew changes).")
w3          = input.float(0.25, "Entropy Exhaustion", step=0.05, group=grp_weight, tooltip="Weighting for Shannon Entropy saturation. High values indicate a disordered market state often preceding a reversal.")
w4          = input.float(0.25, "Edge Denoise", step=0.05, group=grp_weight, tooltip="Weighting for the edge-preserving denoise factor. Filters out low-quality chop based on square-wave proximity.")

// Group: Visuals
grp_vis     = "Visual Settings"
show_hist   = input.bool(true, "Show Histogram", group=grp_vis, tooltip="Toggle the display of the histogram bars representing the oscillator magnitude.")
col_osc     = input.color(#2962FF, "Oscillator Line Color", group=grp_vis, tooltip="Color of the main CHEDO signal line.")
col_hist_up = input.color(#00897B, "Histogram Up Color", group=grp_vis, tooltip="Color of histogram bars when the oscillator is rising.")
col_hist_dn = input.color(#FF9800, "Histogram Down Color", group=grp_vis, tooltip="Color of histogram bars when the oscillator is falling.")
col_zero    = input.color(#787B86, "Zero Line Color", group=grp_vis, tooltip="Color of the zero baseline.")
col_exh     = input.color(#F23645, "Exhaustion Level Color", group=grp_vis, tooltip="Color of the overbought/exhaustion threshold line.")
col_chaos   = input.color(#4CAF50, "Chaos Level Color", group=grp_vis, tooltip="Color of the oversold/chaos threshold line.")
col_bg_up   = input.color(#F23645, "Background Exhaustion", group=grp_vis, tooltip="Background color trigger when value exceeds 0.7.")
col_bg_dn   = input.color(#4CAF50, "Background Chaos", group=grp_vis, tooltip="Background color trigger when value drops below -0.7.")

// === Calculations ===

// Log returns
ret = ta.change(math.log(close))
if na(ret)
    ret := 0.0

// 1. Hyperbolic Geodesic Curvature Proxy
mu_r     = ta.sma(ret, length)
sigma_r  = ta.stdev(ret, length)
v        = sigma_r / (math.abs(mu_r) + 1e-8)  // Coefficient of variation

abs_ret_v = math.abs(ret) * v
hyper_dist = math.log(abs_ret_v + math.sqrt(abs_ret_v * abs_ret_v + 1))  // arcsinh
kappa_h   = tanh(ta.sma(hyper_dist, length)) // Used custom tanh function

// 2. Local Lyapunov Exponent (stabilized)
diff_ret = ta.change(ret)
lyap_term = math.log(math.abs(diff_ret) + 1e-6)  // Avoid log(0)
lambda    = ta.sma(lyap_term, length)

// Normalize lambda (empirical scaling to ~[0,1])
lambda_norm = (lambda - (-5)) / (2 - (-5))  // Rough observed range for returns ~ [-5,2]

// 3. KS-like Regime Shift Proxy (fast moment divergence)
// Compare recent volatility & "shape" to longer-term
short_vol = ta.stdev(ret, length / 2)
long_vol  = ta.stdev(ret, length)
vol_ratio = short_vol / (long_vol + 1e-8)

short_skew = ta.sma(math.pow(ret - mu_r, 3), length / 2) / math.pow(short_vol + 1e-8, 1.5)
long_skew  = ta.sma(math.pow(ret - mu_r, 3), length) / math.pow(long_vol + 1e-8, 1.5)
skew_diff  = math.abs(short_skew - long_skew)

d_ks_proxy = math.min(vol_ratio + skew_diff, 2.0)  // Cap for scaling
d_ks_norm  = (d_ks_proxy - 1.0) * -1  // Higher when shift detected (inverted for consistency)

// 4. Shannon Entropy (fixed bins around zero)
var float[] bin_counts = array.new_float(bins * 2 + 1, 0.0)  // -bins to +bins + zero

// Decay old counts (approximate rolling window)
decay = 1.0 - 1.0 / length
for i = 0 to array.size(bin_counts) - 1
    array.set(bin_counts, i, array.get(bin_counts, i) * decay)

// Determine bin for current return (fixed range based on historical sigma)
range_est = sigma_r * 3  // Cover ~99.7% assuming normality
bin_width = range_est / bins
bin_idx   = bin_width > 0 ? math.round(ret / bin_width) : 0
bin_idx   := math.max(math.min(bin_idx + bins, bins * 2), 0)  // Shift for negative

array.set(bin_counts, bin_idx, array.get(bin_counts, bin_idx) + 1.0)

// Calculate entropy
h = 0.0
total = 0.0
for i = 0 to array.size(bin_counts) - 1
    total += array.get(bin_counts, i)
for i = 0 to array.size(bin_counts) - 1
    p = array.get(bin_counts, i) / (total + 1e-8)
    if p > 0
        h -= p * math.log(p)
h_max = math.log(bins * 2 + 1)
entropy_exhaust = (h_max - h) / h_max  // Normalized [0,1]

// 5. Simple Edge-Preserving Denoise Factor
alternating = ret - ret[2]  // Rough square-wave proxy
f_den = math.abs(ta.sma(alternating, length)) / (ta.sma(math.abs(ret), length) + 1e-8)

// Fusion
hyper_chaos = kappa_h * lambda_norm
weighted = w1 * hyper_chaos + w2 * d_ks_norm + w3 * entropy_exhaust + w4 * f_den

// Bound and smooth
raw_chedo = 2 / (1 + math.exp(-weighted * 4)) - 1  // Steeper sigmoid for better extremes
chedo = ta.sma(raw_chedo, smooth_len)

// === Plotting ===

plot(chedo, title="CHEDO", color=col_osc, linewidth=2)
plot(0, "Zero", color=col_zero)
hline(0.7, "Exhaustion", color=col_exh, linestyle=hline.style_dotted)
hline(-0.7, "Chaos/Reversal", color=col_chaos, linestyle=hline.style_dotted)

// Global logic for conditional coloring (fixing local scope error)
hist_color_logic = chedo > chedo[1] ? col_hist_up : col_hist_dn
final_hist_color = show_hist ? hist_color_logic : na
plot(chedo, style=plot.style_histogram, color=final_hist_color, linewidth=4, title="Histogram")

bgcolor(chedo > 0.7 ? color.new(col_bg_up, 90) : chedo < -0.7 ? color.new(col_bg_dn, 90) : na, title="Exhaustion Zones")

// === Alerts ===

alertcondition(ta.crossover(chedo, 0), "CHEDO Bullish Regime Shift", "Potential trend start")
alertcondition(ta.crossunder(chedo, 0), "CHEDO Bearish Regime Shift", "Potential reversal")
alertcondition(chedo > 0.7, "CHEDO Trend Exhaustion", "Parabolic move likely topping")
alertcondition(chedo < -0.7, "CHEDO Chaos Zone", "High disorder - expect volatility spike")

// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© DarkPoolCrypto

//@version=6
indicator("Î© â€“ Riemannâ€“Quantumâ€“Lyapunovâ€“Reynolds Fusion Oscillator", overlay=false, max_lines_count=0, max_labels_count=0)

//-------------------- USER CONTROLS --------------------
length       = input.int(252,  "Look-back for entropy & CDF")
chaosLen     = input.int(55,   "Lyapunov embedding length")
reThresh     = input.float(1.8,"Reynolds laminarâ†’turbulent threshold")
psiThresh    = input.float(0.35,"Quantum-tunnel probability threshold")
entropyMax   = input.float(0.92,"Entropy exhaustion level")
src          = input.source(close, "Price source")

//-------------------- 0. MATH KERNEL (CUSTOM FUNCTIONS) --------------------
// Pine Script lacks native hyperbolic trig and log2, so we define them here.

// Hyperbolic Cosine: cosh(x) = (e^x + e^-x) / 2
f_cosh(float x) =>
    (math.exp(x) + math.exp(-x)) / 2.0

// Hyperbolic Tangent: tanh(x) = (e^2x - 1) / (e^2x + 1)
f_tanh(float x) =>
    // Clamp to avoid overflow on extreme Reynolds numbers
    float x_clamped = math.max(math.min(x, 20.0), -20.0) 
    float e2x = math.exp(2 * x_clamped)
    (e2x - 1) / (e2x + 1)

// Log Base 2: log2(x) = ln(x) / ln(2)
f_log2(float x) =>
    math.log(x) / math.log(2)

//-------------------- 1. QUANTUM TUNNEL PROBABILITY --------------------
// Very thin rectangular barrier: V0 = ÏƒÂ², width w = ATR
// T â‰ˆ sechÂ²(Îº w) with Îº = sqrt(2m(V0-E))/Ä§  â†’ we rescale to market units
atr     = ta.atr(14)
v0      = ta.stdev(src, length)        // "barrier height"
e       = math.abs(src - src[length])  // "particle energy"
kappa   = math.sqrt(math.max(0, v0 - e)) / atr

// sech(x) = 1/cosh(x)
// psi = sechÂ²(kappa)
psi     = 1 / math.pow(f_cosh(kappa), 2)

//-------------------- 2. LYAPUNOV EXPONENT --------------------
// Rosenstein algorithm simplified: divergence of nearest-neighbour distance
// We define delta-flow (df) here to ensure consistency
df      = src - src[1] 

dist    = array.new_float()
for i = 0 to chaosLen - 1
    // Access historical df safely
    array.push(dist, math.abs(df[i]))

// Largest exponent â‰ˆ mean log-divergence
lyap    = array.size(dist) > 1 ? math.log(array.avg(dist)) : 0.0

//-------------------- 3. REYNOLDS NUMBER --------------------
// Re = Ï u L / Î¼  â†’ map Ï=vol, u=|dP/dt|, L=atr, Î¼=Ïƒ
// We calculate change separately to satisfy the compiler warning
rawChange = ta.change(src)
rho       = volume
u         = math.abs(rawChange)
L         = atr
mu        = ta.stdev(src, length)
Re        = rho * u * L / math.max(mu, 1e-10)

//-------------------- 4. ENTROPY --------------------
// Shannon entropy of price returns inside look-back
bins    = 16
// Use the pre-calculated 'rawChange' variable instead of calling ta.change() inside the loop
minRet  = ta.lowest(rawChange, length)
maxRet  = ta.highest(rawChange, length)
step    = (maxRet - minRet) / bins

var float ent = 0.0

if step > 0
    hist = array.new_float(bins, 0.0)
    for i = 0 to length - 1
        // FIX: Accessing the history of the pre-calculated variable
        current_change = rawChange[i] 
        idx = int((current_change - minRet) / step)
        
        if idx >= 0 and idx < bins
            array.set(hist, idx, array.get(hist, idx) + 1.0)
            
    ent := 0.0
    for j = 0 to bins - 1
        p = array.get(hist, j) / length
        ent := ent - (p > 0 ? p * f_log2(p) : 0.0) // using custom log2
    ent := ent / f_log2(float(bins))               // normalise 0â†’1

//-------------------- 5. COMPLEX Î© CONSTRUCTION --------------------
ReStar  = ta.sma(Re, length)
Smax    = entropyMax
// Î© = Î¨ Â· exp(iÂ·Ï€Â·Î») Â· tanh(Re/Re*) Â· (1 â€“ S/Smax)
mod     = psi * f_tanh(Re / ReStar) * math.max(0, 1 - ent / Smax)
omegaIm = mod * math.sin(math.pi * lyap)   // imaginary part
omegaMag= mod                              // |Î©|

//-------------------- PLOTS & BACKGROUND --------------------
plot(omegaIm, title="Im[Î©]", color=color.orange, linewidth=2)
hline(0, color=color.gray)

// Critical-line zero-cross while probability high
zeroCross = (omegaIm > 0 and omegaIm[1] <= 0) or (omegaIm < 0 and omegaIm[1] >= 0)
alertCondition = zeroCross and omegaMag > psiThresh and Re > reThresh and ent > entropyMax
bgcolor(alertCondition ? color.new(color.yellow, 70) : na, title="Fusion Alert")

//-------------------- OPTIONAL DEBUG --------------------
plot(omegaMag, title="|Î©|", display=display.data_window)
plot(Re,       title="Re", display=display.data_window)
plot(ent,      title="Entropy", display=display.data_window)

// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© DarkPoolCrypto

//@version=6
indicator(title="Chaotic Hyperbolic Entropy Divergence Oscillator (CHEDO) v2 - Optimized", shorttitle="CHEDO v2", overlay=false, max_lines_count=500, max_labels_count=500)

// === Custom Functions ===

// @function Calculates the hyperbolic tangent of a number.
// @param x The input value.
// @returns The hyperbolic tangent of x.
tanh(float x) =>
    // Clamp to avoid overflow with math.exp
    float clamped_x = x > 20.0 ? 20.0 : x < -20.0 ? -20.0 : x
    float e2x = math.exp(2.0 * clamped_x)
    (e2x - 1.0) / (e2x + 1.0)

// === Inputs ===

// Group: Settings
grp_sett = "Calculation Settings"
length      = input.int(50, "Lookback Length", minval=20, group=grp_sett, tooltip="The rolling window size used for statistical calculations including volatility, skewness, and entropy decay.")
smooth_len  = input.int(3, "CHEDO Smoothing Length", minval=1, group=grp_sett, tooltip="The length of the Simple Moving Average applied to the final oscillator to reduce noise.")
bins        = input.int(10, "Entropy Bins (per side)", minval=5, group=grp_sett, tooltip="Number of histogram bins used on each side of the zero mean for Shannon Entropy calculation. Higher values increase resolution but may add noise.")

// Group: Weights
grp_weight = "Component Weights"
w1          = input.float(0.25, "Hyperbolic Curvature Ã— Chaos", step=0.05, group=grp_weight, tooltip="Weighting for the Hyperbolic Geodesic Curvature and Local Lyapunov Exponent fusion. Measures trend curvature and chaotic divergence.")
w2          = input.float(0.25, "Regime Shift (KS Proxy)", step=0.05, group=grp_weight, tooltip="Weighting for the Kolmogorov-Smirnov proxy. Detects structural breaks in the return distribution (e.g., sudden volatility or skew changes).")
w3          = input.float(0.25, "Entropy Exhaustion", step=0.05, group=grp_weight, tooltip="Weighting for Shannon Entropy saturation. High values indicate a disordered market state often preceding a reversal.")
w4          = input.float(0.25, "Edge Denoise", step=0.05, group=grp_weight, tooltip="Weighting for the edge-preserving denoise factor. Filters out low-quality chop based on square-wave proximity.")

// Group: Visuals
grp_vis     = "Visual Settings"
show_hist   = input.bool(true, "Show Histogram", group=grp_vis, tooltip="Toggle the display of the histogram bars representing the oscillator magnitude.")
col_osc     = input.color(#2962FF, "Oscillator Line Color", group=grp_vis, tooltip="Color of the main CHEDO signal line.")
col_hist_up = input.color(#00897B, "Histogram Up Color", group=grp_vis, tooltip="Color of histogram bars when the oscillator is rising.")
col_hist_dn = input.color(#FF9800, "Histogram Down Color", group=grp_vis, tooltip="Color of histogram bars when the oscillator is falling.")
col_zero    = input.color(#787B86, "Zero Line Color", group=grp_vis, tooltip="Color of the zero baseline.")
col_exh     = input.color(#F23645, "Exhaustion Level Color", group=grp_vis, tooltip="Color of the overbought/exhaustion threshold line.")
col_chaos   = input.color(#4CAF50, "Chaos Level Color", group=grp_vis, tooltip="Color of the oversold/chaos threshold line.")
col_bg_up   = input.color(#F23645, "Background Exhaustion", group=grp_vis, tooltip="Background color trigger when value exceeds 0.7.")
col_bg_dn   = input.color(#4CAF50, "Background Chaos", group=grp_vis, tooltip="Background color trigger when value drops below -0.7.")

// === Calculations ===

// Log returns
ret = ta.change(math.log(close))
if na(ret)
    ret := 0.0

// 1. Hyperbolic Geodesic Curvature Proxy
mu_r     = ta.sma(ret, length)
sigma_r  = ta.stdev(ret, length)
v        = sigma_r / (math.abs(mu_r) + 1e-8)  // Coefficient of variation

abs_ret_v = math.abs(ret) * v
hyper_dist = math.log(abs_ret_v + math.sqrt(abs_ret_v * abs_ret_v + 1))  // arcsinh
kappa_h   = tanh(ta.sma(hyper_dist, length)) // Used custom tanh function

// 2. Local Lyapunov Exponent (stabilized)
diff_ret = ta.change(ret)
lyap_term = math.log(math.abs(diff_ret) + 1e-6)  // Avoid log(0)
lambda    = ta.sma(lyap_term, length)

// Normalize lambda (empirical scaling to ~[0,1])
lambda_norm = (lambda - (-5)) / (2 - (-5))  // Rough observed range for returns ~ [-5,2]

// 3. KS-like Regime Shift Proxy (fast moment divergence)
// Compare recent volatility & "shape" to longer-term
short_vol = ta.stdev(ret, length / 2)
long_vol  = ta.stdev(ret, length)
vol_ratio = short_vol / (long_vol + 1e-8)

short_skew = ta.sma(math.pow(ret - mu_r, 3), length / 2) / math.pow(short_vol + 1e-8, 1.5)
long_skew  = ta.sma(math.pow(ret - mu_r, 3), length) / math.pow(long_vol + 1e-8, 1.5)
skew_diff  = math.abs(short_skew - long_skew)

d_ks_proxy = math.min(vol_ratio + skew_diff, 2.0)  // Cap for scaling
d_ks_norm  = (d_ks_proxy - 1.0) * -1  // Higher when shift detected (inverted for consistency)

// 4. Shannon Entropy (fixed bins around zero)
var float[] bin_counts = array.new_float(bins * 2 + 1, 0.0)  // -bins to +bins + zero

// Decay old counts (approximate rolling window)
decay = 1.0 - 1.0 / length
for i = 0 to array.size(bin_counts) - 1
    array.set(bin_counts, i, array.get(bin_counts, i) * decay)

// Determine bin for current return (fixed range based on historical sigma)
range_est = sigma_r * 3  // Cover ~99.7% assuming normality
bin_width = range_est / bins
bin_idx   = bin_width > 0 ? math.round(ret / bin_width) : 0
bin_idx   := math.max(math.min(bin_idx + bins, bins * 2), 0)  // Shift for negative

array.set(bin_counts, bin_idx, array.get(bin_counts, bin_idx) + 1.0)

// Calculate entropy
h = 0.0
total = 0.0
for i = 0 to array.size(bin_counts) - 1
    total += array.get(bin_counts, i)
for i = 0 to array.size(bin_counts) - 1
    p = array.get(bin_counts, i) / (total + 1e-8)
    if p > 0
        h -= p * math.log(p)
h_max = math.log(bins * 2 + 1)
entropy_exhaust = (h_max - h) / h_max  // Normalized [0,1]

// 5. Simple Edge-Preserving Denoise Factor
alternating = ret - ret[2]  // Rough square-wave proxy
f_den = math.abs(ta.sma(alternating, length)) / (ta.sma(math.abs(ret), length) + 1e-8)

// Fusion
hyper_chaos = kappa_h * lambda_norm
weighted = w1 * hyper_chaos + w2 * d_ks_norm + w3 * entropy_exhaust + w4 * f_den

// Bound and smooth
raw_chedo = 2 / (1 + math.exp(-weighted * 4)) - 1  // Steeper sigmoid for better extremes
chedo = ta.sma(raw_chedo, smooth_len)

// === Plotting ===

plot(chedo, title="CHEDO", color=col_osc, linewidth=2)
plot(0, "Zero", color=col_zero)
hline(0.7, "Exhaustion", color=col_exh, linestyle=hline.style_dotted)
hline(-0.7, "Chaos/Reversal", color=col_chaos, linestyle=hline.style_dotted)

// Global logic for conditional coloring (fixing local scope error)
hist_color_logic = chedo > chedo[1] ? col_hist_up : col_hist_dn
final_hist_color = show_hist ? hist_color_logic : na
plot(chedo, style=plot.style_histogram, color=final_hist_color, linewidth=4, title="Histogram")

bgcolor(chedo > 0.7 ? color.new(col_bg_up, 90) : chedo < -0.7 ? color.new(col_bg_dn, 90) : na, title="Exhaustion Zones")

// === Alerts ===

alertcondition(ta.crossover(chedo, 0), "CHEDO Bullish Regime Shift", "Potential trend start")
alertcondition(ta.crossunder(chedo, 0), "CHEDO Bearish Regime Shift", "Potential reversal")
alertcondition(chedo > 0.7, "CHEDO Trend Exhaustion", "Parabolic move likely topping")
alertcondition(chedo < -0.7, "CHEDO Chaos Zone", "High disorder - expect volatility spike")


// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© DarkPoolCrypto

//@version=6
indicator("Apex Vector [Flux + Efficiency] v4.1", shorttitle="APEX Vector", overlay=false, precision=2, explicit_plot_zorder=true)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: PHYSICS CONSTANTS (THE BRAIN)
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const float DEF_EFF_SUPER  = 0.60
const float DEF_EFF_RESIST = 0.30

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: INPUTS - ENGINE
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string G_PHYS = "Physics Engine (Advanced)"
float eff_super  = input.float(DEF_EFF_SUPER, "Superconductor Threshold", minval=0.1, maxval=1.0, step=0.05, group=G_PHYS)
float eff_resist = input.float(DEF_EFF_RESIST, "Resistive Threshold", minval=0.0, maxval=0.5, step=0.05, group=G_PHYS)
int   vol_norm   = input.int(55, "Volume Normalization", minval=10, group=G_PHYS)

string G_CALC = "Vector Calculations"
int   len_vec    = input.int(14, "Vector Length", minval=2, group=G_CALC)
string sm_type   = input.string("EMA", "Smoothing Type", options=["EMA", "SMA", "RMA", "WMA", "VWMA"], group=G_CALC)
int   len_sm     = input.int(5, "Smoothing Length", minval=1, group=G_CALC)
bool  use_vol    = input.bool(true, "Integrate Volume Flux", group=G_CALC)
float strictness = input.float(1.0, "Global Strictness", step=0.1, group=G_CALC)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: INPUTS - DIVERGENCE
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string G_DIV = "Divergence Engine"
bool show_div    = input.bool(true, "Show Divergences", group=G_DIV)
int  div_look    = input.int(5, "Pivot Lookback", minval=1, group=G_DIV)
bool show_reg    = input.bool(true, "Regular (Reversal)", group=G_DIV)
bool show_hid    = input.bool(false, "Hidden (Continuation)", group=G_DIV)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: INPUTS - VISUALS
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string G_VIS = "Visuals: Chart & Histogram"
bool show_bar    = input.bool(true, "Colorize Price Bars", group=G_VIS)
bool use_grad    = input.bool(true, "Gradient Intensity", group=G_VIS)

color c_super_up = input.color(#00E676, "Superconductor (Bull)", group=G_VIS)
color c_super_dn = input.color(#FF1744, "Superconductor (Bear)", group=G_VIS)
color c_resist   = input.color(#546E7A, "Resistive (Chop)", group=G_VIS)
color c_heat     = input.color(#FFD600, "High Heat (Warning)", group=G_VIS)
color c_div_bull = input.color(#00B0FF, "Div Bull", group=G_VIS)
color c_div_bear = input.color(#FF4081, "Div Bear", group=G_VIS)

string G_HUD = "Visuals: Heads-Up Display"
bool   hud_show    = input.bool(true, "Show HUD", group=G_HUD)
bool   hud_compact = input.bool(false, "Compact Mode", group=G_HUD)
string hud_pos     = input.string("Top Right", "Position", options=["Top Right", "Bottom Right", "Top Left", "Bottom Left"], group=G_HUD)
string hud_size    = input.string("Small", "Size", options=["Tiny", "Small", "Normal", "Large"], group=G_HUD)
color  hud_bg      = input.color(color.new(#000000, 20), "Background", group=G_HUD)
color  hud_txt     = input.color(color.new(#FFFFFF, 0), "Text", group=G_HUD)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: CALCULATIONS
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. Geometric Efficiency
series float range_abs = high - low
series float body_abs  = math.abs(close - open)
series float raw_eff   = range_abs == 0 ? 0.0 : body_abs / range_abs
series float efficiency = ta.ema(raw_eff, len_vec)

// 2. Volume Flux
series float vol_avg   = ta.sma(volume, vol_norm)
series float vol_fact  = use_vol ? (vol_avg == 0 ? 1.0 : volume / vol_avg) : 1.0

// 3. The Apex Vector
series float direction  = math.sign(close - open)
series float vector_raw = direction * efficiency * vol_fact

// 4. Smoothing Kernel
float flux = switch sm_type
    "EMA"  => ta.ema(vector_raw, len_sm)
    "SMA"  => ta.sma(vector_raw, len_sm)
    "RMA"  => ta.rma(vector_raw, len_sm)
    "WMA"  => ta.wma(vector_raw, len_sm)
    "VWMA" => ta.vwma(vector_raw, len_sm)
    => ta.ema(vector_raw, len_sm)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: LOGIC & STATE MACHINE
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
float th_super  = eff_super * strictness
float th_resist = eff_resist * strictness

bool is_super_bull = flux > th_super
bool is_super_bear = flux < -th_super
bool is_resistive  = math.abs(flux) < th_resist
bool is_heat       = not is_super_bull and not is_super_bear and not is_resistive

// Gradient Intensity
float flux_abs = math.abs(flux)
float safe_th = th_super == 0 ? 0.1 : th_super
float intensity_raw = is_resistive ? 30 : (flux_abs / safe_th) * 100
float intensity = math.min(intensity_raw, 95) 
float alpha_val = use_grad ? (100 - intensity) : 0

color base_col = is_super_bull ? c_super_up :
                 is_super_bear ? c_super_dn :
                 is_resistive  ? c_resist :
                 c_heat
color state_col = color.new(base_col, alpha_val)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: DIVERGENCE ENGINE (FIXED)
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. Identify Pivots
float ph = ta.pivothigh(flux, div_look, div_look)
float pl = ta.pivotlow(flux, div_look, div_look)

// 2. Memory Variables (Stores the Previous Pivot Data)
var float prev_pl_flux  = na
var float prev_pl_price = na
var float prev_ph_flux  = na
var float prev_ph_price = na

// 3. Detection Logic
bool div_bull_reg = false
bool div_bull_hid = false
bool div_bear_reg = false
bool div_bear_hid = false

// Bullish Check
if not na(pl)
    // Get the price low corresponding to the flux pivot
    float price_at_pivot = low[div_look]
    
    if show_div and not na(prev_pl_flux)
        // Regular Bull: Lower Price, Higher Flux
        if price_at_pivot < prev_pl_price and pl > prev_pl_flux
            div_bull_reg := show_reg
        // Hidden Bull: Higher Price, Lower Flux
        if price_at_pivot > prev_pl_price and pl < prev_pl_flux
            div_bull_hid := show_hid
    
    // Update Memory
    prev_pl_flux  := pl
    prev_pl_price := price_at_pivot

// Bearish Check
if not na(ph)
    // Get the price high corresponding to the flux pivot
    float price_at_pivot = high[div_look]
    
    if show_div and not na(prev_ph_flux)
        // Regular Bear: Higher Price, Lower Flux
        if price_at_pivot > prev_ph_price and ph < prev_ph_flux
            div_bear_reg := show_reg
        // Hidden Bear: Lower Price, Higher Flux
        if price_at_pivot < prev_ph_price and ph > prev_ph_flux
            div_bear_hid := show_hid
            
    // Update Memory
    prev_ph_flux  := ph
    prev_ph_price := price_at_pivot

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: PLOTTING
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
hline(0, "Ground", color=color.new(color.gray, 50), linestyle=hline.style_dotted)

plot(flux, "Flux Vector", color=state_col, style=plot.style_columns, linewidth=1)

plotshape(div_bull_reg ? flux[div_look] : na, "Reg Bull", shape.circle, location.absolute, c_div_bull, offset=-div_look, size=size.tiny)
plotshape(div_bull_hid ? flux[div_look] : na, "Hid Bull", shape.cross, location.absolute, c_div_bull, offset=-div_look, size=size.tiny)
plotshape(div_bear_reg ? flux[div_look] : na, "Reg Bear", shape.circle, location.absolute, c_div_bear, offset=-div_look, size=size.tiny)
plotshape(div_bear_hid ? flux[div_look] : na, "Hid Bear", shape.cross, location.absolute, c_div_bear, offset=-div_look, size=size.tiny)

var line ln_upper = line.new(na, na, na, na, color=color.new(c_super_up, 80))
var line ln_lower = line.new(na, na, na, na, color=color.new(c_super_dn, 80))
line.set_xy1(ln_upper, bar_index, th_super)
line.set_xy2(ln_upper, bar_index + 10, th_super)
line.set_xy1(ln_lower, bar_index, -th_super)
line.set_xy2(ln_lower, bar_index + 10, -th_super)

color bar_tint = show_bar ? base_col : na
barcolor(bar_tint, title="Vector Bar Color")

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: HUD ENGINE
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var table hud = na

string pos_const = switch hud_pos
    "Top Right"     => position.top_right
    "Top Left"      => position.top_left
    "Bottom Right"  => position.bottom_right
    "Bottom Left"   => position.bottom_left
    => position.top_right

string size_const = switch hud_size
    "Tiny"   => size.tiny
    "Small"  => size.small
    "Normal" => size.normal
    "Large"  => size.large
    => size.small

if hud_show and barstate.islast
    int rows = hud_compact ? 2 : 5
    if na(hud)
        hud := table.new(pos_const, 2, rows, bgcolor=hud_bg, frame_width=1, frame_color=color.new(color.gray, 50), border_width=1, border_color=color.new(color.gray, 80))
    
    string s_txt = is_super_bull ? "SUPER (BULL)" : (is_super_bear ? "SUPER (BEAR)" : (is_resistive ? "RESISTIVE" : "HIGH HEAT"))
    string div_status = div_bull_reg ? "Bull Reg" : (div_bear_reg ? "Bear Reg" : (div_bull_hid ? "Bull Hid" : (div_bear_hid ? "Bear Hid" : "None")))
    color div_col = (div_bull_reg or div_bull_hid) ? c_div_bull : ((div_bear_reg or div_bear_hid) ? c_div_bear : hud_txt)
    
    // Header
    table.cell(hud, 0, 0, "APEX VECTOR", text_color=hud_txt, text_size=size_const, text_halign=text.align_left)
    table.cell(hud, 1, 0, "v4.1",        text_color=color.gray,  text_size=size_const, text_halign=text.align_right)
    
    // State
    table.cell(hud, 0, 1, "STATE",       text_color=hud_txt, text_size=size_const, text_halign=text.align_left)
    table.cell(hud, 1, 1, s_txt,         text_color=base_col,    text_size=size_const, text_halign=text.align_right) 
    
    if not hud_compact
        table.cell(hud, 0, 2, "EFFICIENCY",  text_color=hud_txt, text_size=size_const, text_halign=text.align_left)
        table.cell(hud, 1, 2, str.tostring(efficiency * 100, "#") + "%", text_color=color.gray, text_size=size_const, text_halign=text.align_right)
        
        table.cell(hud, 0, 3, "FLUX",        text_color=hud_txt, text_size=size_const, text_halign=text.align_left)
        table.cell(hud, 1, 3, str.tostring(flux, "#.00"), text_color=base_col, text_size=size_const, text_halign=text.align_right)

        table.cell(hud, 0, 4, "DIV ALERT",   text_color=hud_txt, text_size=size_const, text_halign=text.align_left)
        table.cell(hud, 1, 4, div_status,    text_color=div_col,     text_size=size_const, text_halign=text.align_right)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: ALERTS
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Static Alerts
alertcondition(is_super_bull and not is_super_bull[1], "Apex: Superconductor Bull", "Market Entered Bullish Superconductor")
alertcondition(is_super_bear and not is_super_bear[1], "Apex: Superconductor Bear", "Market Entered Bearish Superconductor")
alertcondition(div_bull_reg, "Apex: Bull Div", "Regular Bullish Divergence")
alertcondition(div_bear_reg, "Apex: Bear Div", "Regular Bearish Divergence")

// Dynamic Webhooks
if barstate.isconfirmed
    if is_super_bull and not is_super_bull[1]
        alert("Apex Vector: BULLISH Superconductor Triggered | Flux: " + str.tostring(flux) + " | Price: " + str.tostring(close), alert.freq_once_per_bar_close)
    if is_super_bear and not is_super_bear[1]
        alert("Apex Vector: BEARISH Superconductor Triggered | Flux: " + str.tostring(flux) + " | Price: " + str.tostring(close), alert.freq_once_per_bar_close)
    if is_heat and not is_heat[1]
        alert("Apex Vector: HIGH HEAT Warning (Possible Reversal) | Flux: " + str.tostring(flux), alert.freq_once_per_bar_close)


// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© DarkPoolCrypto

//@version=6
indicator("Quantum Apex: Unified Field [SMC + Vector] v7.0", shorttitle="Quantum Apex", overlay=true, precision=2, max_boxes_count=500, max_lines_count=500, max_labels_count=500, explicit_plot_zorder=true)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: UI & STYLE SETTINGS
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string GRP_UI = "ğŸ¨ UI & HUD"
string TABLE_POS  = input.string("Bottom Right", "HUD Position", options=["Top Right", "Bottom Right", "Top Left", "Bottom Left"], group=GRP_UI)
string TABLE_SIZE = input.string("Small", "HUD Size", options=["Tiny", "Small", "Normal"], group=GRP_UI)
bool   SHOW_LABELS= input.bool(false, "Show Chart Labels", group=GRP_UI, tooltip="Toggle text for BOS/FVG. Keep OFF for clean look.")
bool   SHOW_BARCOL= input.bool(true, "Color Bars by Vector", group=GRP_UI)
bool   SHOW_WTRMRK= input.bool(false, "Show Vector Watermark", group=GRP_UI, tooltip="Plots a scaled version of the Apex Vector at the bottom of the chart.")

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: APEX PHYSICS ENGINE (The Brain)
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string G_PHYS = "âš›ï¸ Apex Physics Engine"
float EFF_SUPER  = input.float(0.60, "Superconductor Threshold", minval=0.1, step=0.05, group=G_PHYS, tooltip="The efficiency required to trigger a trend state.")
float EFF_RESIST = input.float(0.30, "Resistive Threshold", minval=0.0, step=0.05, group=G_PHYS, tooltip="Below this value, the market is considered in a chop/range.")
int   LEN_VEC    = input.int(14, "Vector Lookback", minval=2, group=G_PHYS)
int   VOL_NORM   = input.int(55, "Volume Normalization", minval=10, group=G_PHYS)
string SM_TYPE   = input.string("EMA", "Smoothing", options=["EMA", "SMA", "RMA", "VWMA"], group=G_PHYS)
int   LEN_SM     = input.int(5, "Smoothing Length", minval=1, group=G_PHYS)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: SPACETIME GEOMETRY (SMC)
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string G_SMC = "ğŸŒŒ Spacetime (SMC)"
bool WORMHOLES      = input.bool(true, "Wormholes (FVG)", group=G_SMC)
bool EVENT_HORIZONS = input.bool(true, "Event Horizons (OB)", group=G_SMC)
bool STRUCTURE      = input.bool(true, "Structure (BOS/CHoCH)", group=G_SMC)
int  SMC_LOOKBACK   = input.int(5, "Pivot Lookback", minval=2, group=G_SMC)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SECTION: COLORS & THEME
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string G_VIS = "ğŸ¨ Theme Colors"
color C_SUPER_UP = input.color(#00E676, "Superconductor Bull", group=G_VIS)
color C_SUPER_DN = input.color(#FF1744, "Superconductor Bear", group=G_VIS)
color C_RESIST   = input.color(#546E7A, "Resistive / Chop", group=G_VIS)
color C_HEAT     = input.color(#FFD600, "High Heat / Reversal", group=G_VIS)
color C_DIV      = input.color(#00B0FF, "Divergence Signal", group=G_VIS)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HELPER FUNCTIONS
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Progress Bar for HUD
f_bar(float _val, float _limit, int _len) =>
    float norm = math.min(math.abs(_val) / _limit, 1.0)
    int filled = int(math.round(norm * _len))
    string s = ""
    if filled > 0
        for i = 1 to filled
            s := s + "â– "
    if filled < _len
        for i = 1 to (_len - filled)
            s := s + "â–«"
    s

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CALCULATION: APEX VECTOR
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. Geometric Efficiency
float range_abs = high - low
float body_abs  = math.abs(close - open)
float raw_eff   = range_abs == 0 ? 0.0 : body_abs / range_abs
float efficiency = ta.ema(raw_eff, LEN_VEC)

// 2. Volume Flux
float vol_avg  = ta.sma(volume, VOL_NORM)
float vol_fact = (vol_avg == 0) ? 1.0 : (volume / vol_avg)

// 3. The Apex Vector
float direction = math.sign(close - open)
float vector_raw = direction * efficiency * vol_fact

// 4. Smoothing
float apex_flux = switch SM_TYPE
    "EMA"  => ta.ema(vector_raw, LEN_SM)
    "SMA"  => ta.sma(vector_raw, LEN_SM)
    "RMA"  => ta.rma(vector_raw, LEN_SM)
    "VWMA" => ta.vwma(vector_raw, LEN_SM)
    => ta.ema(vector_raw, LEN_SM)

// State Logic
bool is_super_bull = apex_flux > EFF_SUPER
bool is_super_bear = apex_flux < -EFF_SUPER
bool is_resistive  = math.abs(apex_flux) < EFF_RESIST
bool is_heat       = not is_super_bull and not is_super_bear and not is_resistive

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CALCULATION: DIVERGENCE ENGINE
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
int div_look = 5
float ph = ta.pivothigh(apex_flux, div_look, div_look)
float pl = ta.pivotlow(apex_flux, div_look, div_look)

var float prev_pl_flux  = na
var float prev_pl_price = na
var float prev_ph_flux  = na
var float prev_ph_price = na

bool div_bull = false
bool div_bear = false
string div_type = ""

// Bullish Div
if not na(pl)
    float price_at_pivot = low[div_look]
    if not na(prev_pl_flux)
        // Regular or Hidden
        if (price_at_pivot < prev_pl_price and pl > prev_pl_flux) or (price_at_pivot > prev_pl_price and pl < prev_pl_flux)
            div_bull := true
            div_type := (price_at_pivot < prev_pl_price) ? "REG" : "HID"
    prev_pl_flux  := pl
    prev_pl_price := price_at_pivot

// Bearish Div
if not na(ph)
    float price_at_pivot = high[div_look]
    if not na(prev_ph_flux)
        if (price_at_pivot > prev_ph_price and ph < prev_ph_flux) or (price_at_pivot < prev_ph_price and ph > prev_ph_flux)
            div_bear := true
            div_type := (price_at_pivot > prev_ph_price) ? "REG" : "HID"
    prev_ph_flux  := ph
    prev_ph_price := price_at_pivot

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CALCULATION: SPACETIME (SMC)
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Wormholes (FVG)
bool wormhole_bull = WORMHOLES and (low > high[2])
bool wormhole_bear = WORMHOLES and (high < low[2])

// Event Horizons (OB)
bool event_horizon_bull = EVENT_HORIZONS and close[1] < open[1] and close > high[1] and is_super_bull
bool event_horizon_bear = EVENT_HORIZONS and close[1] > open[1] and close < low[1] and is_super_bear

// Structure (Pivots for BOS)
float st_ph = ta.pivothigh(high, SMC_LOOKBACK, SMC_LOOKBACK)
float st_pl = ta.pivotlow(low, SMC_LOOKBACK, SMC_LOOKBACK)
var float last_st_high = na
var float last_st_low  = na
if not na(st_ph)
    last_st_high := high[SMC_LOOKBACK]
if not na(st_pl)
    last_st_low := low[SMC_LOOKBACK]

bool bos_bull   = STRUCTURE and not na(last_st_high) and close > last_st_high and high[1] <= last_st_high
bool bos_bear   = STRUCTURE and not na(last_st_low)  and close < last_st_low and low[1] >= last_st_low
bool choch_bull = STRUCTURE and not na(last_st_low)  and close > last_st_low  and apex_flux[1] < -EFF_RESIST
bool choch_bear = STRUCTURE and not na(last_st_high) and close < last_st_high and apex_flux[1] >  EFF_RESIST

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// VISUALIZATION: CHART OVERLAY
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Bar Colors (Driven by Apex)
color active_color = is_super_bull ? C_SUPER_UP : is_super_bear ? C_SUPER_DN : is_resistive ? C_RESIST : C_HEAT
barcolor(SHOW_BARCOL ? active_color : na)

// Ghost Wormholes (Clean UI)
if wormhole_bull
    box.new(bar_index[2], high[2], bar_index, low, border_color=color.new(C_SUPER_UP, 70), border_style=line.style_dotted, bgcolor=color.new(C_SUPER_UP, 92), extend=extend.right, text=SHOW_LABELS?"WH":na, text_size=size.tiny, text_color=color.new(C_SUPER_UP, 50))
if wormhole_bear
    box.new(bar_index[2], high, bar_index, low[2], border_color=color.new(C_SUPER_DN, 70), border_style=line.style_dotted, bgcolor=color.new(C_SUPER_DN, 92), extend=extend.right, text=SHOW_LABELS?"WH":na, text_size=size.tiny, text_color=color.new(C_SUPER_DN, 50))

// Event Horizon Dots
if event_horizon_bull
    label.new(bar_index[1], high[1], "â€¢", color=color.new(C_SUPER_UP, 100), textcolor=C_SUPER_UP, style=label.style_label_down, size=size.small)
if event_horizon_bear
    label.new(bar_index[1], low[1], "â€¢", color=color.new(C_SUPER_DN, 100), textcolor=C_SUPER_DN, style=label.style_label_up, size=size.small)

// Structure Lines
if bos_bull
    line.new(bar_index - 10, last_st_high, bar_index, last_st_high, color=color.new(C_SUPER_UP, 50), width=1, style=line.style_dotted)
    label.new(bar_index, last_st_high, SHOW_LABELS ? "BOS" : "â†‘", color=color.new(C_SUPER_UP, 100), textcolor=C_SUPER_UP, style=label.style_label_down, size=size.tiny)
if bos_bear
    line.new(bar_index - 10, last_st_low, bar_index, last_st_low, color=color.new(C_SUPER_DN, 50), width=1, style=line.style_dotted)
    label.new(bar_index, last_st_low, SHOW_LABELS ? "BOS" : "â†“", color=color.new(C_SUPER_DN, 100), textcolor=C_SUPER_DN, style=label.style_label_up, size=size.tiny)

// Watermark Visualizer (Apex on Chart)
// Plots the oscillator at the very bottom of the visible chart area for context
var float scale_max = ta.highest(high, 100)
var float scale_min = ta.lowest(low, 100)
float chart_range = scale_max - scale_min
float watermark_y = low - (chart_range * 0.05) // Just below price
plotchar(SHOW_WTRMRK ? watermark_y : na, "Watermark", "â– ", location.absolute, color=color.new(active_color, 60), size=size.tiny)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// VISUALIZATION: UNIFIED HUD
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var string pos_in = switch TABLE_POS
    "Top Right" => position.top_right
    "Bottom Right" => position.bottom_right
    "Top Left" => position.top_left
    "Bottom Left" => position.bottom_left
    => position.bottom_right

var string size_in = switch TABLE_SIZE
    "Tiny" => size.tiny
    "Small" => size.small
    "Normal" => size.normal
    => size.small

var table hud = table.new(pos_in, 2, 6, bgcolor=color.new(#000000, 50), border_width=0)

if barstate.islast
    // Header
    table.cell(hud, 0, 0, "âš› APEX UNIFIED", text_color=color.new(#7C4DFF, 0), text_size=size_in, text_halign=text.align_left)
    string state_icon = is_super_bull ? "ğŸš€" : is_super_bear ? "ğŸ”»" : is_resistive ? "ğŸ’¤" : "ğŸ”¥"
    table.cell(hud, 1, 0, state_icon, text_color=color.white, text_size=size_in, text_halign=text.align_right)

    // Apex Vector
    string bar = f_bar(apex_flux, EFF_SUPER * 1.5, 6)
    table.cell(hud, 0, 1, "Vector", text_color=color.gray, text_size=size_in, text_halign=text.align_left)
    table.cell(hud, 1, 1, bar, text_color=active_color, text_size=size_in, text_halign=text.align_right)

    // Efficiency
    table.cell(hud, 0, 2, "Efficiency", text_color=color.gray, text_size=size_in, text_halign=text.align_left)
    table.cell(hud, 1, 2, str.tostring(efficiency * 100, "#") + "%", text_color=color.silver, text_size=size_in, text_halign=text.align_right)

    // Structure
    string s_txt = bos_bull ? "BOS+" : bos_bear ? "BOS-" : choch_bull ? "CH+" : choch_bear ? "CH-" : "--"
    color s_col  = (bos_bull or choch_bull) ? C_SUPER_UP : (bos_bear or choch_bear) ? C_SUPER_DN : color.gray
    table.cell(hud, 0, 3, "Struct", text_color=color.gray, text_size=size_in, text_halign=text.align_left)
    table.cell(hud, 1, 3, s_txt, text_color=s_col, text_size=size_in, text_halign=text.align_right)

    // Divergence Alert
    string d_txt = div_bull ? "BULL " + div_type : div_bear ? "BEAR " + div_type : "NONE"
    color d_col  = div_bull ? C_DIV : div_bear ? C_DIV : color.gray
    table.cell(hud, 0, 4, "Divergence", text_color=color.gray, text_size=size_in, text_halign=text.align_left)
    table.cell(hud, 1, 4, d_txt, text_color=d_col, text_size=size_in, text_halign=text.align_right)

    // Signal
    string rec = "WAIT"
    color rec_c = color.gray
    if is_super_bull and bos_bull
        rec := "LONG"
        rec_c := C_SUPER_UP
    else if is_super_bear and bos_bear
        rec := "SHORT"
        rec_c := C_SUPER_DN
    
    table.cell(hud, 0, 5, "Signal", text_color=color.gray, text_size=size_in, text_halign=text.align_left)
    table.cell(hud, 1, 5, rec, text_color=rec_c, text_size=size_in, text_halign=text.align_right, bgcolor=color.new(rec_c, 80))

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ALERTS
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
alertcondition(is_super_bull and not is_super_bull[1], "Apex: Superconductor Bull", "Bullish Superconductor Detected")
alertcondition(is_super_bear and not is_super_bear[1], "Apex: Superconductor Bear", "Bearish Superconductor Detected")
alertcondition(bos_bull, "SMC: Bullish Break", "Bullish BOS Detected")
alertcondition(div_bull, "Apex: Bullish Divergence", "Bullish Divergence Detected")

if barstate.isconfirmed
    if is_super_bull and not is_super_bull[1]
        alert("ğŸš€ SUPERCONDUCTOR BULL | Vector: " + str.tostring(apex_flux), alert.freq_once_per_bar_close)
    if div_bull or div_bear
        alert("âš ï¸ DIVERGENCE DETECTED", alert.freq_once_per_bar_close)


/ This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© DarkPoolCrypto

//@version=6
indicator("Apex Trend & Liquidity Master (SMC)v7.2", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 1. SYSTEM CONFIGURATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// --- Trend & Signals ---
grp_sig   = "ğŸŒŠ Trend & Signals (Original)"
// DEFAULT: ON (Ready to trade)
show_sig  = input.bool(true, "Show Buy/Sell Signals", group=grp_sig, tooltip="Restored: Momentum-based entry signals.")
// DEFAULT: ON (Ready to trade)
show_sl   = input.bool(true, "Show Trailing Stop", group=grp_sig, tooltip="Restored: ATR-based trailing stop line.")
ma_type   = input.string("HMA", "Trend Algorithm", options=["EMA", "SMA", "HMA", "RMA"], group=grp_sig, tooltip="Selects baseline formula.")
len_main  = input.int(55, "Trend Length", minval=10, group=grp_sig, tooltip="Lookback period for the main trend.")
mult      = input.float(1.5, "Volatility Multiplier", step=0.1, group=grp_sig, tooltip="Controls cloud width. Higher = Conservative.")
src       = input.source(close, "Source", group=grp_sig, tooltip="Price source.")

// --- Classic Supply & Demand ---
grp_sd    = "ğŸ§± Classic Supply & Demand"
show_sd   = input.bool(true, "Show Swing S/D Zones", group=grp_sd, tooltip="Restored: Original pivot-based liquidity zones.")
liq_len   = input.int(10, "Pivot Lookback", group=grp_sd, tooltip="Sensitivity of pivots.")
sd_ext    = input.int(20, "Extension", group=grp_sd, tooltip="Bars to extend swing zones.")

// --- Smart Money Concepts (SMC) ---
grp_smc   = "ğŸ›ï¸ Smart Money Concepts (New)"
show_bos  = input.bool(true, "Show BOS/CHoCH", group=grp_smc, tooltip="Market Structure Breaks (High Contrast).")
show_ob   = input.bool(true, "Show Order Blocks", group=grp_smc, tooltip="Specific institutional candles (Ghost Mode).")
show_fvg  = input.bool(true, "Show FVG", group=grp_smc, tooltip="Fair Value Gaps (Ghost Mode).")
fvg_mit   = input.bool(true, "Auto-Delete Mitigated", group=grp_smc, tooltip="Cleans up chart by removing tested zones.")

// --- Visual Palette (Distinct Shades) ---
grp_vis   = "ğŸ¨ Distinct Color Palette"

// 1. Trend Colors (Deep/Dark)
c_tr_bull = input.color(#00695C, "Trend: Bullish (Deep Teal)", group=grp_vis, tooltip="Used for the Cloud and Bar Colors.")
c_tr_bear = input.color(#B71C1C, "Trend: Bearish (Maroon)", group=grp_vis, tooltip="Used for the Cloud and Bar Colors.")

// 2. Signal/Structure Colors (Bright/Neon)
c_sig_bull = input.color(#00E676, "Action: Bullish (Neon Green)", group=grp_vis, tooltip="Used for Buy Signals, BOS, and Trailing Stop.")
c_sig_bear = input.color(#FF1744, "Action: Bearish (Neon Red)", group=grp_vis, tooltip="Used for Sell Signals, BOS, and Trailing Stop.")

// 3. Classic S/D Colors (Standard)
c_sd_bull = input.color(#43A047, "Classic Demand (Forest)", group=grp_vis, tooltip="Used for Pivot-based Demand Zones.")
c_sd_bear = input.color(#E53935, "Classic Supply (Brick)", group=grp_vis, tooltip="Used for Pivot-based Supply Zones.")

// 4. SMC Colors (Pale/Ghost)
c_smc_bull = input.color(#B9F6CA, "SMC Demand (Pale Mint)", group=grp_vis, tooltip="Used for Order Blocks & FVGs (High Transparency).")
c_smc_bear = input.color(#FFCDD2, "SMC Supply (Pale Rose)", group=grp_vis, tooltip="Used for Order Blocks & FVGs (High Transparency).")


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2. TREND & SIGNALS ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// --- Dynamic MA ---
get_ma(t, s, l) =>
    t == "SMA" ? ta.sma(s, l) : t == "EMA" ? ta.ema(s, l) : t == "HMA" ? ta.hma(s, l) : ta.rma(s, l)

baseline = get_ma(ma_type, src, len_main)
atr      = ta.atr(len_main)
upper    = baseline + (atr * mult)
lower    = baseline - (atr * mult)

var int trend = 0
if close > upper
    trend := 1
else if close < lower
    trend := -1

// --- Signal Filters (ADX + Momentum) ---
[di_plus, di_minus, adx] = ta.dmi(14, 14)
adx_ok = adx > 20

// WaveTrend Calculation
ap = hlc3, esa = ta.ema(ap, 10), d = ta.ema(math.abs(ap - esa), 10)
ci = (ap - esa) / (0.015 * d), tci = ta.ema(ci, 21)
mom_buy = tci < 60
mom_sell = tci > -60

// Volume Filter
vol_avg = ta.sma(volume, 20)
vol_ok = volume > vol_avg

// Signal Logic
sig_buy  = trend == 1 and trend[1] != 1 and vol_ok and mom_buy and adx_ok
sig_sell = trend == -1 and trend[1] != -1 and vol_ok and mom_sell and adx_ok

// --- Trailing Stop ---
var float trail_stop = na
trail_atr = ta.atr(14) * 2.0
if trend == 1
    trail_stop := math.max(nz(trail_stop, close), close - trail_atr)
    if trend[1] == -1 
        trail_stop := close - trail_atr
else if trend == -1
    trail_stop := math.min(nz(trail_stop, close), close + trail_atr)
    if trend[1] == 1 
        trail_stop := close + trail_atr

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 3. CLASSIC SUPPLY & DEMAND (PIVOTS)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ph = ta.pivothigh(high, liq_len, liq_len)
pl = ta.pivotlow(low, liq_len, liq_len)

var box[] sd_zones = array.new_box()
manage_zones(arr, lim) =>
    if array.size(arr) > lim
        box.delete(array.shift(arr))

if not na(ph) and show_sd
    // Classic Supply: Solid Standard Colors
    b = box.new(bar_index - liq_len, high[liq_len], bar_index + sd_ext, math.max(open[liq_len], close[liq_len]), 
         border_color=color.new(c_sd_bear, 50), bgcolor=color.new(c_sd_bear, 70), 
         text="Supply", text_color=color.new(color.white, 20), text_size=size.tiny)
    array.push(sd_zones, b)
    manage_zones(sd_zones, 10)

if not na(pl) and show_sd
    // Classic Demand: Solid Standard Colors
    b = box.new(bar_index - liq_len, low[liq_len], bar_index + sd_ext, math.min(open[liq_len], close[liq_len]), 
         border_color=color.new(c_sd_bull, 50), bgcolor=color.new(c_sd_bull, 70), 
         text="Demand", text_color=color.new(color.white, 20), text_size=size.tiny)
    array.push(sd_zones, b)
    manage_zones(sd_zones, 10)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 4. SMC LOGIC (BOS / CHoCH / OB / FVG)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// --- Active Structure Tracking ---
var float last_ph = na
var float last_pl = na
var float lower_high = na
var float higher_low = na

if not na(ph)
    last_ph := high[liq_len]
    if trend == -1
        lower_high := last_ph
if not na(pl)
    last_pl := low[liq_len]
    if trend == 1
        higher_low := last_pl

x_ph = ta.crossover(close, last_ph)
x_pl = ta.crossunder(close, last_pl)
x_lh = ta.crossover(close, lower_high)
x_hl = ta.crossunder(close, higher_low)

// --- Visualizing BOS & CHoCH (Uses Neon Signal Colors) ---
if show_bos
    if trend == 1 and x_ph
        line.new(bar_index - 10, last_ph, bar_index, last_ph, color=c_sig_bull, style=line.style_solid, width=2)
        label.new(bar_index, last_ph, "BOS", color=color(na), textcolor=c_sig_bull, style=label.style_none, size=size.normal)
    if trend == -1 and x_pl
        line.new(bar_index - 10, last_pl, bar_index, last_pl, color=c_sig_bear, style=line.style_solid, width=2)
        label.new(bar_index, last_pl, "BOS", color=color(na), textcolor=c_sig_bear, style=label.style_none, size=size.normal)
    if trend == -1 and x_lh
        line.new(bar_index - 10, lower_high, bar_index, lower_high, color=c_sig_bull, style=line.style_solid, width=2)
        label.new(bar_index, lower_high, "CHoCH", color=color(na), textcolor=c_sig_bull, style=label.style_none, size=size.normal)
        higher_low := low 
    if trend == 1 and x_hl
        line.new(bar_index - 10, higher_low, bar_index, higher_low, color=c_sig_bear, style=line.style_solid, width=2)
        label.new(bar_index, higher_low, "CHoCH", color=color(na), textcolor=c_sig_bear, style=label.style_none, size=size.normal)
        lower_high := high 

// --- Order Blocks & FVGs (Uses Pale SMC Colors) ---
var box[] ob_zones = array.new_box()
var box[] fvg_zones = array.new_box()

// OB Logic
if trend == 1 and x_ph and show_ob
    for i = 1 to 20
        if close[i] < open[i]
            array.push(ob_zones, box.new(bar_index[i], high[i], bar_index + sd_ext, low[i], border_color=na, bgcolor=color.new(c_smc_bull, 80)))
            manage_zones(ob_zones, 5)
            break
if trend == -1 and x_pl and show_ob
    for i = 1 to 20
        if close[i] > open[i]
            array.push(ob_zones, box.new(bar_index[i], high[i], bar_index + sd_ext, low[i], border_color=na, bgcolor=color.new(c_smc_bear, 80)))
            manage_zones(ob_zones, 5)
            break

// FVG Logic
atr_c = ta.atr(14)
fvg_b = (low > high[2]) and (low - high[2] > atr_c * 0.5)
fvg_s = (high < low[2]) and (low[2] - high > atr_c * 0.5)

if show_fvg
    if fvg_b
        array.push(fvg_zones, box.new(bar_index[2], high[2], bar_index + sd_ext, low, border_color=na, bgcolor=color.new(c_smc_bull, 80)))
    if fvg_s
        array.push(fvg_zones, box.new(bar_index[2], low[2], bar_index + sd_ext, high, border_color=na, bgcolor=color.new(c_smc_bear, 80)))
    manage_zones(fvg_zones, 10)

// Mitigation
if fvg_mit
    if array.size(ob_zones) > 0
        for i = array.size(ob_zones) - 1 to 0
            b = array.get(ob_zones, i), bt = box.get_top(b), bb = box.get_bottom(b)
            if (close > bt and bt > bb) or (close < bb and bb < bt)
                box.delete(b), array.remove(ob_zones, i)
            else
                box.set_right(b, bar_index + 5)
    if array.size(fvg_zones) > 0
        for i = array.size(fvg_zones) - 1 to 0
            b = array.get(fvg_zones, i), bt = box.get_top(b), bb = box.get_bottom(b)
            if (close > bt and bt > bb) or (close < bb and bb < bt)
                box.delete(b), array.remove(fvg_zones, i)
            else
                box.set_right(b, bar_index + 5)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 5. PLOTTING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Trend Cloud (Deep Context Colors - Dynamic)
p1 = plot(upper, display=display.none)
p2 = plot(lower, display=display.none)
// FIXED: Cloud color switches fully based on Trend
c_cloud_fill = trend == 1 ? color.new(c_tr_bull, 85) : color.new(c_tr_bear, 85)
fill(p1, p2, color=c_cloud_fill, title="Trend Cloud")

// Trailing Stop (Neon Action Colors)
plot(show_sl ? trail_stop : na, "Trailing Stop", color=trend==1?c_sig_bull:c_sig_bear, style=plot.style_linebr, linewidth=2)

// Signals (Neon Action Colors)
if show_sig and sig_buy
    label.new(bar_index, low, "BUY", color=c_sig_bull, textcolor=color.white, style=label.style_label_up, size=size.small)
if show_sig and sig_sell
    label.new(bar_index, high, "SELL", color=c_sig_bear, textcolor=color.white, style=label.style_label_down, size=size.small)

// Bar Color (Deep Context Colors)
barcolor(trend == 1 ? c_tr_bull : trend == -1 ? c_tr_bear : na)

// Alerts
alertcondition(sig_buy, "Apex Buy Signal", "Trend Following Buy Signal")
alertcondition(sig_sell, "Apex Sell Signal", "Trend Following Sell Signal")


import streamlit as st
import yfinance as yf
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import pandas as pd
import numpy as np
from openai import OpenAI
import calendar
import datetime
import requests
import urllib.parse
from scipy.stats import linregress
import matplotlib.pyplot as plt  # Explicitly imported to ensure Pandas styling works

# ==========================================
# 1. PAGE CONFIGURATION & CUSTOM UI
# ==========================================
st.set_page_config(layout="wide", page_title="ğŸ¦Titan Terminal", page_icon="ğŸ‘ï¸")

# --- CUSTOM CSS FOR "DARKPOOL" AESTHETIC ---
st.markdown("""
<style>
.stApp {
    background-color: #0e1117;
    color: #e0e0e0;
    font-family: 'Roboto Mono', monospace;
}
.title-glow {
    font-size: 3em;
    font-weight: bold;
    color: #ffffff;
    text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 40px #00ff00;
    margin-bottom: 20px;
}
div[data-testid="stMetric"] {
    background-color: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    padding: 10px;
    border-radius: 8px;
    transition: transform 0.2s;
}
div[data-testid="stMetric"]:hover {
    transform: scale(1.02);
    border-color: #00ff00;
}
div[data-testid="stMetricValue"] {
    font-size: 1.2rem !important;
    font-weight: 700;
}
.stTabs [data-baseweb="tab-list"] {
    gap: 2px;
    background-color: transparent;
}
.stTabs [data-baseweb="tab"] {
    height: 50px;
    white-space: pre-wrap;
    background-color: #161b22;
    border-radius: 4px 4px 0px 0px;
    gap: 1px;
    padding-top: 10px;
    padding-bottom: 10px;
    border: 1px solid #30363d;
    color: #8b949e;
}
.stTabs [aria-selected="true"] {
    background-color: #0e1117;
    color: #00ff00;
    border-bottom: 2px solid #00ff00;
}
div[data-testid="stVerticalBlockBorderWrapper"] {
    border-color: #30363d !important;
}
</style>
""", unsafe_allow_html=True)

# --- HEADER ---
st.markdown('<div class="title-glow">ğŸ‘ï¸ DarkPool Titan Terminal</div>', unsafe_allow_html=True)
st.markdown("##### *Institutional-Grade Market Intelligence*")
st.markdown("---")

# --- API Key Management (UPGRADED FOR SECRETS) ---
if 'api_key' not in st.session_state:
    st.session_state.api_key = None

# 1. Check Streamlit Secrets First
if "OPENAI_API_KEY" in st.secrets:
    st.session_state.api_key = st.secrets["OPENAI_API_KEY"]

# 2. Fallback to Manual Input
if not st.session_state.api_key:
    st.session_state.api_key = st.sidebar.text_input(
        "OpenAI API Key", 
        type="password",
        help="Enter your OpenAI API key here to unlock the AI Analyst features."
    )

# ==========================================
# 2. DATA ENGINE (OPTIMIZED FOR SPEED)
# ==========================================
@st.cache_data(ttl=3600)
def get_fundamentals(ticker):
    """Fetches key financial metrics safely."""
    if "-" in ticker or "=" in ticker or "^" in ticker: 
        return None 
    try:
        stock = yf.Ticker(ticker)
        info = stock.info
        if not info: return None

        return {
            "Market Cap": info.get("marketCap", 0),
            "P/E Ratio": info.get("trailingPE", 0),
            "Rev Growth": info.get("revenueGrowth", 0),
            "Debt/Equity": info.get("debtToEquity", 0),
            "Summary": info.get("longBusinessSummary", "No Data Available")
        }
    except: return None

@st.cache_data(ttl=300)
def get_global_performance():
    """Fetches performance of a Global Multi-Asset Basket."""
    assets = {
        "Tech (XLK)": "XLK", 
        "Energy (XLE)": "XLE", 
        "Financials (XLF)": "XLF", 
        "Bitcoin (BTC)": "BTC-USD", 
        "Gold (GLD)": "GLD", 
        "Oil (USO)": "USO", 
        "Treasuries (TLT)": "TLT"
    }
    try:
        tickers_list = list(assets.values())
        data = yf.download(tickers_list, period="5d", interval="1d", progress=False, group_by='ticker')

        results = {}
        for name, ticker in assets.items():
            try:
                if len(tickers_list) > 1:
                    df = data[ticker]
                else:
                    df = data 

                if not df.empty and len(df) >= 2:
                    if 'Close' in df.columns: price_col = 'Close'
                    elif 'Adj Close' in df.columns: price_col = 'Adj Close'
                    else: continue

                    price = df[price_col].iloc[-1]
                    prev = df[price_col].iloc[-2]
                    change = ((price - prev) / prev) * 100
                    results[name] = change
            except:
                continue

        return pd.Series(results).sort_values(ascending=True)
    except: return None

def safe_download(ticker, period, interval):
    """Robust price downloader."""
    try:
        if interval == "4h":
            dl_interval = "1h"
        else:
            dl_interval = interval

        df = yf.download(ticker, period=period, interval=dl_interval, progress=False)

        if isinstance(df.columns, pd.MultiIndex):
            df.columns = df.columns.get_level_values(0)

        if df.empty: return None

        if 'Close' not in df.columns:
            if 'Adj Close' in df.columns: df['Close'] = df['Adj Close']
            else: return None

        return df
    except: return None

@st.cache_data(ttl=300)
def get_macro_data():
    """Fetches 40 global macro indicators grouped by sector using BATCH DOWNLOAD (FAST)."""
    groups = {
        "ğŸ‡ºğŸ‡¸ US Equities": {
            "S&P 500": "SPY", "Nasdaq 100": "QQQ", "Dow Jones": "^DJI", "Russell 2000": "^RUT"
        },
        "ğŸŒ Global Indices": {
            "FTSE 100": "^FTSE", "DAX": "^GDAXI", "Nikkei 225": "^N225", "Hang Seng": "^HSI"
        },
        "ğŸ¦ Rates & Bonds": {
            "10Y Yield": "^TNX", "2Y Yield": "^IRX", "30Y Yield": "^TYX", "T-Bond (TLT)": "TLT"
        },
        "ğŸ’± Forex & Volatility": {
            "DXY Index": "DX-Y.NYB", "EUR/USD": "EURUSD=X", "USD/JPY": "JPY=X", "VIX (Fear)": "^VIX"
        },
        "âš ï¸ Risk Assets": {
            "Bitcoin": "BTC-USD", "Ethereum": "ETH-USD", "Semis (SMH)": "SMH", "Junk Bonds": "HYG"
        },
        "âš¡ Energy": {
            "WTI Crude": "CL=F", "Brent Crude": "BZ=F", "Natural Gas": "NG=F", "Uranium": "URA"
        },
        "ğŸ¥‡ Precious Metals": {
            "Gold": "GC=F", "Silver": "SI=F", "Platinum": "PL=F", "Palladium": "PA=F"
        },
        "ğŸ—ï¸ Industrial & Ag": {
            "Copper": "HG=F", "Rare Earths": "REMX", "Corn": "ZC=F", "Wheat": "ZW=F"
        },
        "ğŸ‡¬ğŸ‡§ UK Desk": {
            "GBP/USD": "GBPUSD=X", "GBP/JPY": "GBPJPY=X", "EUR/GBP": "EURGBP=X", "UK Gilts": "IGLT.L"
        },
        "ğŸ“ˆ Growth & Real Assets": {
            "Emerging Mkts": "EEM", "China (FXI)": "FXI", "Real Estate": "VNQ", "Soybeans": "ZS=F"
        }
    }

    all_tickers_list = []
    ticker_to_name_map = {}
    for g_name, g_dict in groups.items():
        for t_name, t_sym in g_dict.items():
            all_tickers_list.append(t_sym)
            ticker_to_name_map[t_sym] = t_name

    try:
        data_batch = yf.download(all_tickers_list, period="5d", interval="1d", group_by='ticker', progress=False)
        prices = {}
        changes = {}

        for sym in all_tickers_list:
            try:
                if len(all_tickers_list) > 1:
                    df = data_batch[sym]
                else:
                    df = data_batch

                if df is None or df.empty: continue
                df = df.dropna(how='all')

                if len(df) >= 2:
                    col = 'Close' if 'Close' in df.columns else 'Adj Close'
                    curr = df[col].iloc[-1]
                    prev = df[col].iloc[-2]
                    chg = ((curr - prev) / prev) * 100

                    name = ticker_to_name_map.get(sym, sym)
                    prices[name] = curr
                    changes[name] = chg
            except Exception:
                continue

        return groups, prices, changes

    except Exception as e:
        return groups, {}, {}

# ==========================================
# 3. MATH LIBRARY & ALGORITHMS (UPDATED FOR GOD MODE)
# ==========================================

# --- Helper Math Functions for Pine Script Translation ---
def calculate_wma(series, length):
    return series.rolling(length).apply(lambda x: np.dot(x, np.arange(1, length + 1)) / (length * (length + 1) / 2), raw=True)

def calculate_hma(series, length):
    half_length = int(length / 2)
    sqrt_length = int(np.sqrt(length))
    wma_half = calculate_wma(series, half_length)
    wma_full = calculate_wma(series, length)
    diff = 2 * wma_half - wma_full
    return calculate_wma(diff, sqrt_length)

def calculate_atr(df, length=14):
    high_low = df['High'] - df['Low']
    high_close = np.abs(df['High'] - df['Close'].shift())
    low_close = np.abs(df['Low'] - df['Close'].shift())
    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    return tr.rolling(length).mean()

def calculate_supertrend(df, period=10, multiplier=3):
    atr = calculate_atr(df, period)
    hl2 = (df['High'] + df['Low']) / 2
    final_upperband = hl2 + (multiplier * atr)
    final_lowerband = hl2 - (multiplier * atr)
    
    supertrend = [True] * len(df)
    
    # Basic iteration for recursive SuperTrend logic (optimized)
    # Using numpy arrays for speed
    close = df['Close'].values
    upper = final_upperband.values
    lower = final_lowerband.values
    st = np.zeros(len(df))
    trend = np.zeros(len(df)) # 1 is UP, -1 is DOWN
    
    # Initial setup
    st[0] = lower[0]
    trend[0] = 1
    
    for i in range(1, len(df)):
        if close[i-1] > st[i-1]: # Previous trend UP
            st[i] = max(lower[i], st[i-1]) if close[i] > st[i-1] else upper[i]
            trend[i] = 1 if close[i] > st[i-1] else -1
            if close[i] < lower[i] and trend[i-1] == 1: # Trend Change
                 st[i] = upper[i]
                 trend[i] = -1
        else: # Previous trend DOWN
            st[i] = min(upper[i], st[i-1]) if close[i] < st[i-1] else lower[i]
            trend[i] = -1 if close[i] < st[i-1] else 1
            if close[i] > upper[i] and trend[i-1] == -1: # Trend Change
                st[i] = lower[i]
                trend[i] = 1

    return pd.Series(st, index=df.index), pd.Series(trend, index=df.index)

def calculate_linreg_mom(series, length=20):
    # Vectorized Rolling Linear Regression for Squeeze Momentum
    x = np.arange(length)
    # This is a simplified slope calc for performance
    slope = series.rolling(length).apply(lambda y: linregress(x, y)[0], raw=True)
    # Calculate expected value at end of window
    return slope

def calc_indicators(df):
    """Calculates Base Indicators + 10 GOD MODE INDICATORS"""
    
    # --- 0. Base Calcs ---
    df['HMA'] = calculate_hma(df['Close'], 55) # Replaced with custom HMA function
    df['ATR'] = calculate_atr(df, 14)
    df['Pivot_Resist'] = df['High'].rolling(20).max()
    df['Pivot_Support'] = df['Low'].rolling(20).min()
    df['MFI'] = (df['Close'].diff() * df['Volume']).rolling(14).mean() 

    # ==========================================
    # GOD MODE INDICATOR INTEGRATION
    # ==========================================

    # 1. Apex Trend & Liquidity Master (HMA + ATR Bands)
    apex_mult = 1.5
    df['Apex_Base'] = df['HMA'] # Already calc 55
    df['Apex_ATR'] = calculate_atr(df, 55)
    df['Apex_Upper'] = df['Apex_Base'] + (df['Apex_ATR'] * apex_mult)
    df['Apex_Lower'] = df['Apex_Base'] - (df['Apex_ATR'] * apex_mult)
    df['Apex_Trend'] = np.where(df['Close'] > df['Apex_Upper'], 1, np.where(df['Close'] < df['Apex_Lower'], -1, 0))
    # Fill zeros with previous value to filter chop
    df['Apex_Trend'] = df['Apex_Trend'].replace(to_replace=0, method='ffill')

    # 2. DarkPool Squeeze Momentum
    # BB
    df['Sqz_Basis'] = df['Close'].rolling(20).mean()
    df['Sqz_Dev'] = df['Close'].rolling(20).std() * 2.0
    df['Sqz_Upper_BB'] = df['Sqz_Basis'] + df['Sqz_Dev']
    df['Sqz_Lower_BB'] = df['Sqz_Basis'] - df['Sqz_Dev']
    # KC
    df['Sqz_Ma_KC'] = df['Close'].rolling(20).mean()
    df['Sqz_Range_MA'] = calculate_atr(df, 20)
    df['Sqz_Upper_KC'] = df['Sqz_Ma_KC'] + (df['Sqz_Range_MA'] * 1.5)
    df['Sqz_Lower_KC'] = df['Sqz_Ma_KC'] - (df['Sqz_Range_MA'] * 1.5)
    
    df['Squeeze_On'] = (df['Sqz_Lower_BB'] > df['Sqz_Lower_KC']) & (df['Sqz_Upper_BB'] < df['Sqz_Upper_KC'])
    
    # Momentum (LinReg) - Simplified for speed: Close - Avg(Highest, Lowest)
    highest = df['High'].rolling(20).max()
    lowest = df['Low'].rolling(20).min()
    avg_val = (highest + lowest + df['Sqz_Ma_KC']) / 3
    # Use delta for LinReg proxy
    df['Sqz_Mom'] = (df['Close'] - avg_val).rolling(20).mean() * 100 # Scaling for viz

    # 3. Money Flow Matrix (Normalized RSI * Vol)
    rsi_src = (100 - (100 / (1 + (df['Close'].diff().clip(lower=0).rolling(14).mean() / df['Close'].diff().clip(upper=0).abs().rolling(14).mean())))) - 50
    mf_vol = df['Volume'] / df['Volume'].rolling(14).mean()
    df['MF_Matrix'] = (rsi_src * mf_vol).ewm(span=3).mean()

    # 4. Dark Vector Scalping (Staircase)
    # Using simple Donchian logic for python speed to mimic the pine script staircase
    amp = 5
    df['VS_Low'] = df['Low'].rolling(amp).min()
    df['VS_High'] = df['High'].rolling(amp).max()
    # (Simplified logic: Close > previous High = Bull, Close < previous Low = Bear)
    df['VS_Trend'] = np.where(df['Close'] > df['VS_High'].shift(1), 1, np.where(df['Close'] < df['VS_Low'].shift(1), -1, 0))
    df['VS_Trend'] = df['VS_Trend'].replace(to_replace=0, method='ffill')

    # 5. Advanced Volume (RVOL)
    df['RVOL'] = df['Volume'] / df['Volume'].rolling(20).mean()

    # 6. Elastic Volume Weighted Momentum (EVWM)
    ev_len = 21
    ev_base = calculate_hma(df['Close'], ev_len)
    ev_atr = calculate_atr(df, ev_len)
    ev_elast = (df['Close'] - ev_base) / ev_atr
    ev_force = np.sqrt(df['RVOL'].ewm(span=5).mean())
    df['EVWM'] = ev_elast * ev_force

    # 7. Ultimate S&R (Pivot Breaks)
    # Calculated in Base Calcs as Pivot_Resist/Support

    # 8. Gann High Low Activator
    gann_len = 3
    df['Gann_High'] = df['High'].rolling(gann_len).mean()
    df['Gann_Low'] = df['Low'].rolling(gann_len).mean()
    # Simple logic: Close > Prev Gann High = Bull
    df['Gann_Trend'] = np.where(df['Close'] > df['Gann_High'].shift(1), 1, np.where(df['Close'] < df['Gann_Low'].shift(1), -1, 0))
    df['Gann_Trend'] = df['Gann_Trend'].replace(to_replace=0, method='ffill')

    # 9. Dark Vector (SuperTrend + Chop)
    st_val, st_dir = calculate_supertrend(df, 10, 4.0)
    df['DarkVector_Trend'] = st_dir

    # 10. Wyckoff VSA (Trend Shield)
    df['Trend_Shield_Bull'] = df['Close'] > df['Close'].rolling(200).mean() # SMA 200

    # --- GOD MODE CONFLUENCE SIGNAL ---
    # Summing up trend indicators (1 = Bull, -1 = Bear)
    # Apex, Gann, Vector, VS_Trend, Squeeze Mom > 0
    df['GM_Score'] = (
        df['Apex_Trend'] + 
        df['Gann_Trend'] + 
        df['DarkVector_Trend'] + 
        df['VS_Trend'] + 
        np.sign(df['Sqz_Mom'])
    )
    
    # --- DASHBOARD V2 SPECIFIC CALCULATIONS (Existing) ---
    ema12 = df['Close'].ewm(span=12, adjust=False).mean()
    ema26 = df['Close'].ewm(span=26, adjust=False).mean()
    df['MACD'] = ema12 - ema26
    df['Signal'] = df['MACD'].ewm(span=9, adjust=False).mean()
    df['Hist'] = df['MACD'] - df['Signal']

    low_min = df['Low'].rolling(14).min()
    high_max = df['High'].rolling(14).max()
    df['Stoch_K'] = 100 * (df['Close'] - low_min) / (high_max - low_min)
    df['Stoch_D'] = df['Stoch_K'].rolling(3).mean()

    df['ROC'] = df['Close'].pct_change(14) * 100
    df['EMA_Fast'] = df['Close'].ewm(span=9, adjust=False).mean()
    df['EMA_Slow'] = df['Close'].ewm(span=21, adjust=False).mean()
    df['EMA_50'] = df['Close'].ewm(span=50, adjust=False).mean()

    df['OBV'] = (np.sign(df['Close'].diff()) * df['Volume']).fillna(0).cumsum()
    df['VWAP'] = (df['Volume'] * (df['High'] + df['Low'] + df['Close']) / 3).cumsum() / df['Volume'].cumsum()

    # ADX Calc
    plus_dm = df['High'].diff()
    minus_dm = df['Low'].diff()
    plus_dm[plus_dm < 0] = 0
    minus_dm[minus_dm > 0] = 0
    tr14 = df['ATR']
    plus_di = 100 * (plus_dm.ewm(alpha=1/14).mean() / tr14)
    minus_di = 100 * (minus_dm.ewm(alpha=1/14).mean() / tr14)
    dx = (abs(plus_di - minus_di) / abs(plus_di + minus_di)) * 100
    df['ADX'] = dx.rolling(14).mean()

    delta = df['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(14).mean()
    rs = gain / loss
    df['RSI'] = 100 - (100 / (1 + rs))

    rsi_norm = (df['RSI'] - 50) * 2
    macd_norm = np.where(df['Hist'] > 0, np.minimum(df['Hist'] * 10, 100), np.maximum(df['Hist'] * 10, -100))
    stoch_norm = (df['Stoch_K'] - 50) * 2
    roc_norm = np.where(df['ROC'] > 0, np.minimum(df['ROC'] * 10, 100), np.maximum(df['ROC'] * 10, -100))

    df['Mom_Score'] = np.round((rsi_norm + macd_norm + stoch_norm + roc_norm) / 4)

    return df

def calc_fear_greed_v4(df):
    """
    ğŸ”¥ DarkPool's Fear & Greed v4 Port
    Calculates composite sentiment index, FOMO, and Panic states.
    """
    # 1. RSI Component (30% Weight)
    delta = df['Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)
    avg_gain = gain.ewm(alpha=1/14, adjust=False).mean()
    avg_loss = loss.ewm(alpha=1/14, adjust=False).mean()
    rs = avg_gain / avg_loss
    df['FG_RSI'] = 100 - (100 / (1 + rs))

    # 2. MACD Component (25% Weight)
    ema12 = df['Close'].ewm(span=12, adjust=False).mean()
    ema26 = df['Close'].ewm(span=26, adjust=False).mean()
    macd = ema12 - ema26
    signal = macd.ewm(span=9, adjust=False).mean()
    hist = macd - signal
    df['FG_MACD'] = (50 + (hist * 10)).clip(0, 100)

    # 3. Bollinger Band Component (25% Weight)
    sma20 = df['Close'].rolling(20).mean()
    std20 = df['Close'].rolling(20).std()
    upper = sma20 + (std20 * 2)
    lower = sma20 - (std20 * 2)
    df['FG_BB'] = ((df['Close'] - lower) / (upper - lower) * 100).clip(0, 100)

    # 4. Moving Average Trend (20% Weight)
    sma50 = df['Close'].rolling(50).mean()
    sma200 = df['Close'].rolling(200).mean()

    conditions = [
        (df['Close'] > sma50) & (sma50 > sma200),
        (df['Close'] > sma50),
        (df['Close'] < sma50) & (sma50 < sma200)
    ]
    choices = [75, 60, 25]
    df['FG_MA'] = np.select(conditions, choices, default=40)

    # Composite Index
    df['FG_Raw'] = (df['FG_RSI'] * 0.30) + (df['FG_MACD'] * 0.25) + (df['FG_BB'] * 0.25) + (df['FG_MA'] * 0.20)
    df['FG_Index'] = df['FG_Raw'].rolling(5).mean()

    # --- FOMO LOGIC ---
    vol_ma = df['Volume'].rolling(20).mean()
    high_vol = df['Volume'] > (vol_ma * 2.5)
    high_rsi = df['FG_RSI'] > 70
    momentum = df['Close'] > df['Close'].shift(3) * 1.02
    above_bb = df['Close'] > (upper * 1.0)

    df['IS_FOMO'] = high_vol & high_rsi & momentum & above_bb

    # --- PANIC LOGIC ---
    daily_drop = df['Close'].pct_change() * 100
    sharp_drop = daily_drop < -3.0
    panic_vol = df['Volume'] > (vol_ma * 3.0)
    low_rsi = df['FG_RSI'] < 30

    df['IS_PANIC'] = sharp_drop & panic_vol & (low_rsi | (daily_drop < -5.0))

    return df

def run_monte_carlo(df, days=30, simulations=1000):
    """ğŸ”® Monte Carlo Simulation."""
    last_price = df['Close'].iloc[-1]
    returns = df['Close'].pct_change().dropna()
    mu = returns.mean()
    sigma = returns.std()

    daily_returns_sim = np.random.normal(mu, sigma, (days, simulations))
    price_paths = np.zeros((days, simulations))
    price_paths[0] = last_price

    for t in range(1, days):
        price_paths[t] = price_paths[t-1] * (1 + daily_returns_sim[t])

    return price_paths

def calc_volume_profile(df, bins=50):
    """ğŸ“Š Institutional Volume Profile (VPVR)."""
    price_min = df['Low'].min()
    price_max = df['High'].max()
    price_bins = np.linspace(price_min, price_max, bins)

    df['Mid'] = (df['Close'] + df['Open']) / 2
    df['Bin'] = pd.cut(df['Mid'], bins=price_bins, labels=price_bins[:-1], include_lowest=True)

    vp = df.groupby('Bin')['Volume'].sum().reset_index()
    vp['Price'] = vp['Bin'].astype(float)
    poc_idx = vp['Volume'].idxmax()
    poc_price = vp.loc[poc_idx, 'Price']

    return vp, poc_price

def get_sr_channels(df, pivot_period=10, loopback=290, max_width_pct=5, min_strength=1):
    """Python implementation of 'Support Resistance Channels' logic."""
    if len(df) < loopback: loopback = len(df)
    window = df.iloc[-loopback:].copy()

    window['Is_Pivot_H'] = window['High'] == window['High'].rolling(pivot_period*2+1, center=True).max()
    window['Is_Pivot_L'] = window['Low'] == window['Low'].rolling(pivot_period*2+1, center=True).min()

    pivot_vals = []
    pivot_vals.extend(window[window['Is_Pivot_H']]['High'].tolist())
    pivot_vals.extend(window[window['Is_Pivot_L']]['Low'].tolist())

    if not pivot_vals: return []
    pivot_vals.sort()

    price_range = window['High'].max() - window['Low'].min()
    max_width = price_range * (max_width_pct / 100)

    potential_zones = []
    for i in range(len(pivot_vals)):
        seed = pivot_vals[i]
        cluster_min = seed
        cluster_max = seed
        pivot_count = 1

        for j in range(i + 1, len(pivot_vals)):
            curr = pivot_vals[j]
            if (curr - seed) <= max_width:
                cluster_max = curr
                pivot_count += 1
            else:
                break

        touches = ((window['High'] >= cluster_min) & (window['Low'] <= cluster_max)).sum()
        score = (pivot_count * 20) + touches

        potential_zones.append({'min': cluster_min, 'max': cluster_max, 'score': score})

    potential_zones.sort(key=lambda x: x['score'], reverse=True)

    final_zones = []
    for zone in potential_zones:
        is_overlapping = False
        for existing in final_zones:
            if (zone['min'] < existing['max']) and (zone['max'] > existing['min']):
                is_overlapping = True
                break
        if not is_overlapping:
            final_zones.append(zone)
            if len(final_zones) >= 6: break

    return final_zones

def calculate_smc(df, swing_length=5):
    """ğŸ¦ LuxAlgo Smart Money Concepts."""
    smc_data = {'structures': [], 'order_blocks': [], 'fvgs': []}

    for i in range(2, len(df)):
        if df['Low'].iloc[i] > df['High'].iloc[i-2]:
            smc_data['fvgs'].append({'x0': df.index[i-2], 'x1': df.index[i], 'y0': df['High'].iloc[i-2], 'y1': df['Low'].iloc[i], 'color': 'rgba(0, 255, 104, 0.3)'})
        if df['High'].iloc[i] < df['Low'].iloc[i-2]:
            smc_data['fvgs'].append({'x0': df.index[i-2], 'x1': df.index[i], 'y0': df['Low'].iloc[i-2], 'y1': df['High'].iloc[i], 'color': 'rgba(255, 0, 8, 0.3)'})

    df['Pivot_High'] = df['High'].rolling(window=swing_length*2+1, center=True).max() == df['High']
    df['Pivot_Low'] = df['Low'].rolling(window=swing_length*2+1, center=True).min() == df['Low']

    last_high = None; last_low = None; trend = 0

    for i in range(swing_length, len(df)):
        curr_idx = df.index[i]; curr_close = df['Close'].iloc[i]

        if df['Pivot_High'].iloc[i-swing_length]:
            last_high = {'price': df['High'].iloc[i-swing_length], 'idx': df.index[i-swing_length], 'i': i-swing_length}
        if df['Pivot_Low'].iloc[i-swing_length]:
            last_low = {'price': df['Low'].iloc[i-swing_length], 'idx': df.index[i-swing_length], 'i': i-swing_length}

        if last_high and curr_close > last_high['price']:
            label = "CHoCH" if trend != 1 else "BOS"; trend = 1
            smc_data['structures'].append({'x0': last_high['idx'], 'x1': curr_idx, 'y': last_high['price'], 'color': 'green', 'label': label})
            if last_low:
                subset = df.iloc[last_low['i']:i]
                if not subset.empty:
                    ob_idx = subset['Low'].idxmin(); ob_row = df.loc[ob_idx]
                    smc_data['order_blocks'].append({'x0': ob_idx, 'x1': df.index[-1], 'y0': ob_row['Low'], 'y1': ob_row['High'], 'color': 'rgba(33, 87, 243, 0.4)'})
            last_high = None

        elif last_low and curr_close < last_low['price']:
            label = "CHoCH" if trend != -1 else "BOS"; trend = -1
            smc_data['structures'].append({'x0': last_low['idx'], 'x1': curr_idx, 'y': last_low['price'], 'color': 'red', 'label': label})
            if last_high:
                subset = df.iloc[last_high['i']:i]
                if not subset.empty:
                    ob_idx = subset['High'].idxmax(); ob_row = df.loc[ob_idx]
                    smc_data['order_blocks'].append({'x0': ob_idx, 'x1': df.index[-1], 'y0': ob_row['Low'], 'y1': ob_row['High'], 'color': 'rgba(255, 0, 0, 0.4)'})
            last_low = None

    return smc_data

def calc_correlations(ticker, lookback_days=180):
    """ğŸ§© Cross-Asset Correlation Matrix."""
    macro_tickers = {
        "S&P 500": "SPY", "Bitcoin": "BTC-USD", "10Y Yield": "^TNX", 
        "Dollar (DXY)": "DX-Y.NYB", "Gold": "GC=F", "Oil": "CL=F"
    }

    df_main = yf.download(ticker, period="1y", interval="1d", progress=False)['Close']
    df_macro = yf.download(list(macro_tickers.values()), period="1y", interval="1d", progress=False)['Close']

    combined = df_macro.copy()
    combined[ticker] = df_main
    corr_matrix = combined.iloc[-lookback_days:].corr()
    target_corr = corr_matrix[ticker].drop(ticker).sort_values(ascending=False)

    inv_map = {v: k for k, v in macro_tickers.items()}
    target_corr.index = [inv_map.get(x, x) for x in target_corr.index]

    return target_corr

def calc_mtf_trend(ticker):
    """ğŸ“¡ Multi-Timeframe Trend Radar (Fixed for Multi-Index)."""
    timeframes = {"1H": "1h", "4H": "1h", "Daily": "1d", "Weekly": "1wk"}
    trends = {}

    for tf_name, tf_code in timeframes.items():
        try:
            if tf_name == "1H":
                period = "1y" 
            elif tf_name == "4H":
                period = "1y" 
            else:
                period = "2y"

            df = yf.download(ticker, period=period, interval=tf_code, progress=False)

            if isinstance(df.columns, pd.MultiIndex):
                df.columns = df.columns.get_level_values(0)

            if df.empty or len(df) < 50: 
                trends[tf_name] = {"Trend": "N/A", "RSI": "N/A", "EMA Spread": "N/A"}
                continue

            if tf_name == "4H":
                df = df.resample('4h').agg({'Open':'first', 'High':'max', 'Low':'min', 'Close':'last', 'Volume':'sum'}).dropna()

            df['EMA20'] = df['Close'].ewm(span=20).mean()
            df['EMA50'] = df['Close'].ewm(span=50).mean()

            delta = df['Close'].diff()
            gain = delta.where(delta > 0, 0).rolling(14).mean()
            loss = -delta.where(delta < 0, 0).rolling(14).mean()
            rs = gain / loss
            df['RSI'] = 100 - (100 / (1 + rs))

            last = df.iloc[-1]
            trend = "BULLISH" if last['Close'] > last['EMA20'] and last['EMA20'] > last['EMA50'] else "BEARISH" if last['Close'] < last['EMA20'] and last['EMA20'] < last['EMA50'] else "NEUTRAL"

            trends[tf_name] = {
                "Trend": trend,
                "RSI": f"{last['RSI']:.1f}",
                "EMA Spread": f"{(last['EMA20'] - last['EMA50']):.2f}"
            }
        except:
            trends[tf_name] = {"Trend": "N/A", "RSI": "N/A", "EMA Spread": "N/A"}

    return pd.DataFrame(trends).T

def calc_intraday_dna(ticker):
    """â±ï¸ Intraday Seasonality (Hour of Day)."""
    try:
        df = yf.download(ticker, period="60d", interval="1h", progress=False)
        if isinstance(df.columns, pd.MultiIndex):
            df.columns = df.columns.get_level_values(0)

        if df.empty: return None

        df['Return'] = df['Close'].pct_change() * 100
        df['Hour'] = df.index.hour

        hourly_stats = df.groupby('Hour')['Return'].agg(['mean', 'sum', 'count', lambda x: (x > 0).mean() * 100])
        hourly_stats.columns = ['Avg Return', 'Total Return', 'Count', 'Win Rate']

        return hourly_stats
    except: return None

@st.cache_data(ttl=3600)
def get_seasonality_stats(ticker):
    """Calculates Monthly Seasonality and Probability Stats."""
    try:
        df = yf.download(ticker, period="20y", interval="1mo", progress=False)
        if df.empty or len(df) < 12: return None

        if isinstance(df.columns, pd.MultiIndex):
            df.columns = df.columns.get_level_values(0)

        if 'Close' not in df.columns:
            if 'Adj Close' in df.columns: df['Close'] = df['Adj Close']
            else: return None

        df = df.dropna()
        df['Return'] = df['Close'].pct_change() * 100
        df['Year'] = df.index.year
        df['Month'] = df.index.month

        heatmap_data = df.pivot_table(index='Year', columns='Month', values='Return')

        periods = [1, 3, 6, 12]
        hold_stats = {}
        for p in periods:
            rolling_ret = df['Close'].pct_change(periods=p) * 100
            rolling_ret = rolling_ret.dropna()

            win_count = (rolling_ret > 0).sum()
            total_count = len(rolling_ret)
            win_rate = (win_count / total_count * 100) if total_count > 0 else 0
            avg_ret = rolling_ret.mean()

            hold_stats[p] = {"Win Rate": win_rate, "Avg Return": avg_ret}

        month_stats = df.groupby('Month')['Return'].agg(['mean', lambda x: (x > 0).mean() * 100, 'count'])
        month_stats.columns = ['Avg Return', 'Win Rate', 'Count']

        return heatmap_data, hold_stats, month_stats

    except Exception as e:
        return None

def calc_day_of_week_dna(ticker, lookback, calc_mode):
    """DarkPool's Day of Week Seasonality DNA Port"""
    try:
        df = yf.download(ticker, period="5y", interval="1d", progress=False)
        if df.empty: return None

        if isinstance(df.columns, pd.MultiIndex):
            df.columns = df.columns.get_level_values(0)

        df = df.iloc[-lookback:].copy()

        if calc_mode == "Close to Close (Total)":
            df['Day_Return'] = df['Close'].pct_change() * 100
        else: # Open to Close (Intraday)
            df['Day_Return'] = ((df['Close'] - df['Open']) / df['Open']) * 100

        df = df.dropna()
        df['Day_Name'] = df.index.day_name()

        pivot_ret = df.pivot(columns='Day_Name', values='Day_Return').fillna(0)
        cum_ret = pivot_ret.cumsum()

        stats = df.groupby('Day_Name')['Day_Return'].agg(['count', 'sum', 'mean', lambda x: (x > 0).mean() * 100])
        stats.columns = ['Count', 'Total Return', 'Avg Return', 'Win Rate']

        days_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
        stats = stats.reindex([d for d in days_order if d in stats.index])

        return cum_ret, stats

    except Exception as e:
        return None

# ==========================================
# 4. AI ANALYST (MODIFIED FOR TIMEFRAME & GOD MODE)
# ==========================================
def ask_ai_analyst(df, ticker, fundamentals, balance, risk_pct, timeframe):
    if not st.session_state.api_key: 
        return "âš ï¸ Waiting for OpenAI API Key in the sidebar..."

    last = df.iloc[-1]
    trend = "BULLISH" if last['Close'] > last['HMA'] else "BEARISH"
    risk_dollars = balance * (risk_pct / 100)
    
    # God Mode Score
    gm_score = last['GM_Score']
    gm_verdict = "STRONG BUY" if gm_score >= 3 else "STRONG SELL" if gm_score <= -3 else "NEUTRAL"

    if trend == "BULLISH":
        stop_level = last['Pivot_Support']
        direction = "LONG"
    else:
        stop_level = last['Pivot_Resist']
        direction = "SHORT"

    if pd.isna(stop_level) or abs(last['Close'] - stop_level) < (last['ATR']*0.5):
        stop_level = last['Close'] - (last['ATR']*2) if direction == "LONG" else last['Close'] + (last['ATR']*2)

    dist = abs(last['Close'] - stop_level)
    if dist == 0: dist = last['ATR']
    shares = risk_dollars / dist 

    fund_text = "N/A"
    if fundamentals:
        fund_text = f"P/E: {fundamentals.get('P/E Ratio', 'N/A')}. Growth: {fundamentals.get('Rev Growth', 0)*100:.1f}%."

    fg_val = last['FG_Index']
    fg_state = "EXTREME GREED" if fg_val >= 80 else "GREED" if fg_val >= 60 else "NEUTRAL" if fg_val >= 40 else "FEAR" if fg_val >= 20 else "EXTREME FEAR"
    psych_alert = ""
    if last['IS_FOMO']: psych_alert = "WARNING: ALGORITHMIC FOMO DETECTED."
    if last['IS_PANIC']: psych_alert = "WARNING: PANIC SELLING DETECTED."

    prompt = f"""
    Act as a Senior Market Analyst. Analyze {ticker} on the **{timeframe} timeframe** at price ${last['Close']:.2f}.

    --- DATA FEED ---
    Technicals: Trend is {trend}. Volatility (ATR) is {last['ATR']:.2f}.
    RSI: {last['RSI']:.1f}.
    Volume (RVOL): {last['RVOL']:.1f}x.
    Titan Score: {gm_score} ({gm_verdict}).
    Momentum: {'Rising' if last['Sqz_Mom'] > 0 else 'Falling'}.
    Sentiment: {fg_state} ({fg_val:.1f}/100).
    {psych_alert}
    Fundamentals: {fund_text}

    --- MISSION ---
    Provide a concise, high-level overview of what is happening with this asset.
    1. Analyze the current market structure (Trend vs Chop).
    2. Explain the correlation between the technicals and sentiment.
    3. Provide a general outlook on potential direction.

    IMPORTANT:
    - Do NOT provide specific Entry prices, Exit prices, or Stop Loss numbers.
    - Do NOT give specific financial advice.
    - Keep it to a market situation overview only.
    - **USE EMOJIS liberally to make the report engaging and visually appealing (e.g., ğŸš€, ğŸ“‰, ğŸ‚, ğŸ», ğŸ§ , âš ï¸).**
    """

    try:
        client = OpenAI(api_key=st.session_state.api_key)
        res = client.chat.completions.create(model="gpt-4o", messages=[{"role":"user","content":prompt}], max_tokens=2500)
        return res.choices[0].message.content
    except Exception as e:
        return f"âš ï¸ AI Error: {e}"

# ==========================================
# 5. UI DASHBOARD LAYOUT
# ==========================================
st.sidebar.header("ğŸ›ï¸ Terminal Controls")

# --- BROADCAST CENTER (NEW SIDEBAR) ---
st.sidebar.subheader("ğŸ“¢ Social Broadcaster")

# 1. Initialize Session State
if 'tg_token' not in st.session_state: st.session_state.tg_token = ""
if 'tg_chat' not in st.session_state: st.session_state.tg_chat = ""

# 2. Check Secrets (UPGRADE: Auto-load from st.secrets if available)
if "TELEGRAM_TOKEN" in st.secrets:
    st.session_state.tg_token = st.secrets["TELEGRAM_TOKEN"]
if "TELEGRAM_CHAT_ID" in st.secrets:
    st.session_state.tg_chat = st.secrets["TELEGRAM_CHAT_ID"]

# 3. Create Inputs (Auto-filled if secrets exist, allowing manual override if needed)
tg_token = st.sidebar.text_input("Telegram Bot Token", value=st.session_state.tg_token, type="password", help="Enter your Telegram Bot Token")
tg_chat = st.sidebar.text_input("Telegram Chat ID", value=st.session_state.tg_chat, help="Enter your Telegram Chat ID")

input_mode = st.sidebar.radio("Input Mode:", ["Curated Lists", "Manual Search (Global)"], index=1, help="Select input mode")

# --- MODIFIED ASSETS DICTIONARY (EXPANDED) ---
if input_mode == "Curated Lists":
    assets = {
        "Indices": ["SPY", "QQQ", "DIA", "IWM", "VTI"],
        "Crypto (Top 20)": [
            "BTC-USD", "ETH-USD", "SOL-USD", "BNB-USD", "XRP-USD", 
            "ADA-USD", "DOGE-USD", "AVAX-USD", "DOT-USD", "TRX-USD", 
            "LINK-USD", "MATIC-USD", "SHIB-USD", "LTC-USD", "BCH-USD", 
            "XLM-USD", "ALGO-USD", "ATOM-USD", "UNI-USD", "FIL-USD"
        ],
        "Tech Giants (Top 10)": [
            "NVDA", "TSLA", "AAPL", "MSFT", "GOOGL", 
            "AMZN", "META", "AMD", "NFLX", "INTC"
        ],
        "Macro & Commodities": [
            "^TNX", "DX-Y.NYB", "GC=F", "SI=F", 
            "CL=F", "NG=F", "^VIX", "TLT"
        ]
    }
    cat = st.sidebar.selectbox("Asset Class", list(assets.keys()), help="Select asset class")
    ticker = st.sidebar.selectbox("Ticker", assets[cat], help="Select ticker")
else:
    st.sidebar.info("Type any ticker (e.g. SSLN.L, BTC-USD)")
    # --- FIX: Changed default from "SSLN.L" to "BTC-USD" ---
    ticker = st.sidebar.text_input("Search Ticker Symbol", value="BTC-USD", help="Enter ticker symbol").upper()

interval = st.sidebar.selectbox("Interval", ["15m", "1h", "4h", "1d", "1wk"], index=3, help="Select time interval")
st.sidebar.markdown("---")

balance = st.sidebar.number_input("Capital ($)", 1000, 1000000, 10000, help="Enter your capital")
risk_pct = st.sidebar.slider("Risk %", 0.5, 3.0, 1.0, help="Select risk percentage")

# --- GLOBAL MACRO HEADER ---
macro_groups, m_price, m_chg = get_macro_data()

if m_price:
    group_names = list(macro_groups.keys())
    for i in range(0, len(group_names), 2): 
        cols = st.columns(2)
        g1 = group_names[i]
        with cols[0].container(border=True):
            st.markdown(f"#### {g1}")
            sc = st.columns(4) 
            for x, (n, s) in enumerate(macro_groups[g1].items()):
                fmt = "{:.3f}" if any(c in n for c in ["Yield","GBP","EUR","JPY"]) else "{:,.2f}"
                sc[x].metric(n.split('(')[0], fmt.format(m_price.get(n,0)), f"{m_chg.get(n,0):.2f}%")

        if i + 1 < len(group_names):
            g2 = group_names[i+1]
            with cols[1].container(border=True):
                st.markdown(f"#### {g2}")
                sc = st.columns(4) 
                for x, (n, s) in enumerate(macro_groups[g2].items()):
                    fmt = "{:.3f}" if any(c in n for c in ["Yield","GBP","EUR","JPY"]) else "{:,.2f}"
                    sc[x].metric(n.split('(')[0], fmt.format(m_price.get(n,0)), f"{m_chg.get(n,0):.2f}%")
    st.markdown("---")

# --- MAIN ANALYSIS TABS ---
tab1, tab2, tab3, tab4, tab9, tab5, tab6, tab7, tab8, tab10 = st.tabs([
    "ğŸ“Š God Mode Technicals", 
    "ğŸŒ Sector & Fundamentals", 
    "ğŸ“… Monthly Seasonality", 
    "ğŸ“† Day of Week DNA", 
    "ğŸ§© Correlation & MTF", 
    "ğŸ“Ÿ DarkPool Dashboard", 
    "ğŸ¦ Smart Money Concepts",
    "ğŸ”® Quantitative Forecasting",
    "ğŸ“Š Volume Profile",
    "ğŸ“¡ Broadcast & TradingView"
])

if st.button(f"Analyze {ticker}", help="Run Analysis"):
    st.session_state['run_analysis'] = True

if st.session_state.get('run_analysis'):
    with st.spinner(f"Analyzing {ticker} in God Mode..."):

        # --- FIX: DYNAMIC TIMEFRAME ADJUSTMENT FOR 1H/4H DATA ---
        if interval in ["1m", "2m", "5m", "15m", "30m"]:
            fetch_period = "59d" # Max for 15m is 60d
        elif interval in ["1h", "4h"]: # Updated for 4H support
            fetch_period = "1y" # Max for 1h is 730d, but 1y is safer
        else:
            fetch_period = "2y" # Standard for Daily+

        df = safe_download(ticker, fetch_period, interval)

        # --- FIX: RESAMPLE 4H DATA (Since Yahoo doesn't support it natively) ---
        if interval == "4h" and df is not None:
            # Resample 1h data to 4h
            agg_dict = {'Open': 'first', 'High': 'max', 'Low': 'min', 'Close': 'last', 'Volume': 'sum'}
            if 'Adj Close' in df.columns: agg_dict['Adj Close'] = 'last'
            df = df.resample('4h').agg(agg_dict).dropna()

        if df is not None:
            df = calc_indicators(df)
            df = calc_fear_greed_v4(df)
            fund = get_fundamentals(ticker)
            sr_zones = get_sr_channels(df) 

            # --- TAB 1: TECHNICALS (GOD MODE) ---
            with tab1:
                st.subheader(f"ğŸ¯ Apex God Mode: {ticker}")
                col_chart, col_gauge = st.columns([0.75, 0.25])
                with col_chart:
                    # UPDATED: Using 3 Rows for Price, Squeeze, and Money Flow
                    fig = make_subplots(rows=3, cols=1, shared_xaxes=True, row_heights=[0.6, 0.2, 0.2], vertical_spacing=0.02)
                    
                    # 1. Price + Apex Cloud + Signals
                    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name="Price"), row=1, col=1)
                    
                    # Apex Cloud (Filled Area)
                    fig.add_trace(go.Scatter(x=df.index, y=df['Apex_Upper'], line=dict(width=0), showlegend=False, hoverinfo='skip'), row=1, col=1)
                    fig.add_trace(go.Scatter(x=df.index, y=df['Apex_Lower'], fill='tonexty', fillcolor='rgba(0, 230, 118, 0.1)', line=dict(width=0), name="Apex Cloud"), row=1, col=1)
                    fig.add_trace(go.Scatter(x=df.index, y=df['HMA'], line=dict(color='yellow', width=2), name="HMA Trend"), row=1, col=1)

                    # God Mode Signals (Aggregated)
                    buy_signals = df[df['GM_Score'] >= 3]
                    sell_signals = df[df['GM_Score'] <= -3]
                    
                    fig.add_trace(go.Scatter(x=buy_signals.index, y=buy_signals['Low']*0.98, mode='markers', marker=dict(symbol='triangle-up', color='#00ff00', size=10), name="GM Buy"), row=1, col=1)
                    fig.add_trace(go.Scatter(x=sell_signals.index, y=sell_signals['High']*1.02, mode='markers', marker=dict(symbol='triangle-down', color='#ff0000', size=10), name="GM Sell"), row=1, col=1)

                    for z in sr_zones:
                        col = "rgba(0, 255, 0, 0.15)" if df['Close'].iloc[-1] > z['max'] else "rgba(255, 0, 0, 0.15)"
                        fig.add_shape(type="rect", x0=df.index[0], x1=df.index[-1], xref="x", yref="y", y0=z['min'], y1=z['max'], fillcolor=col, line=dict(width=0), row=1, col=1)
                    
                    # 2. Squeeze Momentum
                    colors = ['#00E676' if v > 0 else '#FF5252' for v in df['Sqz_Mom']]
                    fig.add_trace(go.Bar(x=df.index, y=df['Sqz_Mom'], marker_color=colors, name="Squeeze Mom"), row=2, col=1)
                    
                    # 3. Money Flow Matrix
                    fig.add_trace(go.Scatter(x=df.index, y=df['MF_Matrix'], fill='tozeroy', line=dict(color='cyan', width=1), name="Money Flow"), row=3, col=1)

                    fig.update_layout(height=800, template="plotly_dark", xaxis_rangeslider_visible=False, title_text="God Mode Technical Stack")
                    st.plotly_chart(fig, use_container_width=True)
                
                with col_gauge:
                    fg_val = df['FG_Index'].iloc[-1]
                    fig_gauge = go.Figure(go.Indicator(mode="gauge+number", value=fg_val, title={'text': "Fear & Greed"}, gauge={'axis': {'range': [0, 100]}, 'bar': {'color': "white"}, 'steps': [{'range': [0, 20], 'color': "#FF0000"}, {'range': [80, 100], 'color': "#00FF00"}]}))
                    fig_gauge.update_layout(height=300, margin=dict(l=10, r=10, t=50, b=10), paper_bgcolor="rgba(0,0,0,0)", font={'color': "white"})
                    st.plotly_chart(fig_gauge, use_container_width=True)
                    
                    st.markdown("### ğŸ§¬ Indicator DNA")
                    last_row = df.iloc[-1]
                    st.metric("God Mode Score", f"{last_row['GM_Score']:.0f} / 5", delta="Bullish" if last_row['GM_Score'] > 0 else "Bearish")
                    st.metric("Apex Trend", "BULL" if last_row['Apex_Trend'] == 1 else "BEAR")
                    st.metric("Squeeze", "ON" if last_row['Squeeze_On'] else "OFF")
                    st.metric("Money Flow", f"{last_row['MF_Matrix']:.2f}")

                st.markdown("### ğŸ¤– Strategy Briefing")
                # --- FIX: PASS TIMEFRAME INTERVAL TO AI ANALYST ---
                ai_verdict = ask_ai_analyst(df, ticker, fund, balance, risk_pct, interval)
                st.info(ai_verdict)

            # --- TAB 2: FUNDAMENTALS ---
            with tab2:
                if fund:
                    c1, c2, c3 = st.columns(3)
                    c1.metric("P/E Ratio", f"{fund.get('P/E Ratio', 'N/A')}")
                    c2.metric("Rev Growth", f"{fund.get('Rev Growth', 0)*100:.1f}%")
                    c3.metric("Debt/Equity", f"{fund.get('Debt/Equity', 'N/A')}")
                    st.write(f"**Summary:** {fund.get('Summary', 'No Data')}")
                st.subheader("ğŸ”¥ Global Market Heatmap")
                s_data = get_global_performance()
                if s_data is not None:
                    fig_sector = go.Figure(go.Bar(x=s_data.values, y=s_data.index, orientation='h', marker_color=['#00ff00' if v >= 0 else '#ff0000' for v in s_data.values]))
                    fig_sector.update_layout(height=400, template="plotly_dark")
                    st.plotly_chart(fig_sector, use_container_width=True)

            # --- TAB 3: SEASONALITY ---
            with tab3:
                seas = get_seasonality_stats(ticker)
                if seas:
                    hm, hold, month = seas
                    fig_hm = px.imshow(hm, color_continuous_scale='RdYlGn', text_auto='.1f')
                    fig_hm.update_layout(template="plotly_dark", height=500)
                    st.plotly_chart(fig_hm, use_container_width=True)
                    c1, c2 = st.columns(2)
                    c1.dataframe(pd.DataFrame(hold).T.style.format("{:.1f}%").background_gradient(cmap="RdYlGn"))
                    curr_m = datetime.datetime.now().month
                    c2.metric(f"Current Month Win Rate", f"{month.loc[curr_m, 'Win Rate']:.1f}%")

            # --- TAB 4: DNA & HOURLY ---
            with tab4:
                st.subheader("ğŸ“† Day & Hour DNA")
                c1, c2 = st.columns(2)

                # Day of Week
                dna_res = calc_day_of_week_dna(ticker, 250, "Close to Close (Total)")
                if dna_res:
                    cum, stats = dna_res
                    with c1:
                        st.markdown("**Day of Week Performance**")
                        fig_dna = go.Figure()
                        for c in cum.columns: fig_dna.add_trace(go.Scatter(x=cum.index, y=cum[c], name=c))
                        fig_dna.update_layout(template="plotly_dark", height=400)
                        st.plotly_chart(fig_dna, use_container_width=True)
                        st.dataframe(stats.style.background_gradient(subset=['Win Rate'], cmap="RdYlGn"))

                # Hourly DNA
                hourly_res = calc_intraday_dna(ticker)
                if hourly_res is not None:
                    with c2:
                        st.markdown("**Intraday (Hourly) Performance**")
                        fig_hr = px.bar(hourly_res, x=hourly_res.index, y='Avg Return', color='Win Rate', color_continuous_scale='RdYlGn')
                        fig_hr.update_layout(template="plotly_dark", height=400)
                        st.plotly_chart(fig_hr, use_container_width=True)
                        st.dataframe(hourly_res.style.format("{:.2f}"))

            # --- TAB 9: CORRELATION & MTF ---
            with tab9:
                st.subheader("ğŸ§© Cross-Asset Intelligence")
                c1, c2 = st.columns([0.4, 0.6])

                with c1:
                    st.markdown("**ğŸ“¡ Multi-Timeframe Radar**")
                    mtf_df = calc_mtf_trend(ticker)

                    def color_trend(val):
                        color = '#00ff00' if val == 'BULLISH' else '#ff0000' if val == 'BEARISH' else 'white'
                        return f'color: {color}; font-weight: bold'

                    st.dataframe(mtf_df.style.map(color_trend, subset=['Trend']), use_container_width=True)

                with c2:
                    st.markdown("**ğŸ”— Macro Correlation Matrix (180 Days)**")
                    corr_data = calc_correlations(ticker)
                    fig_corr = px.bar(x=corr_data.values, y=corr_data.index, orientation='h', color=corr_data.values, color_continuous_scale='RdBu')
                    fig_corr.update_layout(template="plotly_dark", height=400, xaxis_title="Correlation Coefficient")
                    st.plotly_chart(fig_corr, use_container_width=True)

            # --- TAB 5: DASHBOARD ---
            with tab5:
                # Updated with God Mode metrics
                last = df.iloc[-1]
                dash_data = {
                    "Metric": ["God Mode Score", "Apex Trend", "Vector Trend", "Gann Trend", "EVWM Momentum", "RVOL"], 
                    "Value": [
                        f"{last['GM_Score']:.0f}", 
                        "BULL" if last['Apex_Trend'] == 1 else "BEAR",
                        "BULL" if last['DarkVector_Trend'] == 1 else "BEAR",
                        "BULL" if last['Gann_Trend'] == 1 else "BEAR",
                        f"{last['EVWM']:.2f}",
                        f"{last['RVOL']:.1f}x"
                    ]
                }
                st.dataframe(pd.DataFrame(dash_data), use_container_width=True)

            # --- TAB 6: SMC ---
            with tab6:
                smc = calculate_smc(df)
                fig_smc = go.Figure(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close']))
                for ob in smc['order_blocks']: fig_smc.add_shape(type="rect", x0=ob['x0'], x1=ob['x1'], y0=ob['y0'], y1=ob['y1'], fillcolor=ob['color'], opacity=0.5, line_width=0)
                for fvg in smc['fvgs']: fig_smc.add_shape(type="rect", x0=fvg['x0'], x1=fvg['x1'], y0=fvg['y0'], y1=fvg['y1'], fillcolor=fvg['color'], opacity=0.5, line_width=0)
                for struct in smc['structures']: 
                    fig_smc.add_shape(type="line", x0=struct['x0'], x1=struct['x1'], y0=struct['y'], y1=struct['y'], line=dict(color=struct['color'], width=1, dash="dot"))
                    fig_smc.add_annotation(x=struct['x1'], y=struct['y'], text=struct['label'], showarrow=False, yshift=10 if struct['color']=='green' else -10, font=dict(color=struct['color'], size=10))

                fig_smc.update_layout(height=600, template="plotly_dark", title="SMC Analysis")
                st.plotly_chart(fig_smc, use_container_width=True)

            # --- TAB 7: QUANT ---
            with tab7:
                mc = run_monte_carlo(df)
                fig_mc = go.Figure()
                for i in range(50): fig_mc.add_trace(go.Scatter(y=mc[:,i], mode='lines', line=dict(color='rgba(255,255,255,0.05)'), showlegend=False))
                fig_mc.add_trace(go.Scatter(y=np.mean(mc, axis=1), mode='lines', name='Mean', line=dict(color='orange')))
                fig_mc.update_layout(height=500, template="plotly_dark", title="Monte Carlo Forecast (30 Days)")
                st.plotly_chart(fig_mc, use_container_width=True)

            # --- TAB 8: VOLUME PROFILE ---
            with tab8:
                vp, poc = calc_volume_profile(df)
                fig_vp = make_subplots(rows=1, cols=2, shared_yaxes=True, column_widths=[0.7, 0.3])
                fig_vp.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close']), row=1, col=1)
                fig_vp.add_trace(go.Bar(x=vp['Volume'], y=vp['Price'], orientation='h', marker_color='rgba(0,200,255,0.3)'), row=1, col=2)
                fig_vp.add_hline(y=poc, line_color="yellow")
                fig_vp.update_layout(height=600, template="plotly_dark", title="Volume Profile (VPVR)")
                st.plotly_chart(fig_vp, use_container_width=True)

            # --- TAB 10: BROADCAST ---
            with tab10:
                st.subheader("ğŸ“¡ Social Command Center")

                # FIX: Map User Timeframe to TradingView Widget Code
                tv_interval_map = {
                    "15m": "15",
                    "1h": "60",
                    "4h": "240",
                    "1d": "D",
                    "1wk": "W"
                }
                tv_int = tv_interval_map.get(interval, "D")

                # TradingView Widget (Embed) - FIX: Added hide_side_toolbar: false
                tv_ticker = ticker.replace("-", "") if "BTC" in ticker else ticker 

                tv_widget_html = f"""
                <div class="tradingview-widget-container">
                    <div id="tradingview_widget"></div>
                    <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
                    <script type="text/javascript">
                    new TradingView.widget(
                    {{
                        "width": "100%",
                        "height": 500,
                        "symbol": "{tv_ticker}",
                        "interval": "{tv_int}",
                        "timezone": "Etc/UTC",
                        "theme": "dark",
                        "style": "1",
                        "locale": "en",
                        "toolbar_bg": "#f1f3f6",
                        "enable_publishing": false,
                        "hide_side_toolbar": false,
                        "allow_symbol_change": true,
                        "container_id": "tradingview_widget"
                    }}
                    );
                    </script>
                </div>
                """
                st.components.v1.html(tv_widget_html, height=500)
                st.caption("Drawing Tools are enabled on the left sidebar.")

                st.markdown("---")
                st.markdown("#### ğŸš€ Broadcast Signal")

                # Signal Message Draft
                # Updated for God Mode Signals
                last_r = df.iloc[-1]
                
                # Macro Context for Signal
                spy_chg = m_chg.get("S&P 500", 0)
                btc_chg = m_chg.get("Bitcoin", 0)
                dxy_chg = m_chg.get("DXY Index", 0)
                gold_chg = m_chg.get("Gold", 0)

                macro_text = f"ğŸŒ SPY: {spy_chg:+.2f}% | BTC: {btc_chg:+.2f}%\nğŸ’µ DXY: {dxy_chg:+.2f}% | ğŸŸ¡ Gold: {gold_chg:+.2f}%"

                gm_emoji = "ğŸŸ¢" if last_r['GM_Score'] > 0 else "ğŸ”´"
                signal_text = f"ğŸ”¥ {ticker} ({interval}) TITAN\n\nPrice: ${last_r['Close']:.2f}\n{gm_emoji} Titan Score: {last_r['GM_Score']:.0f}/5\n\nApex: {'ğŸ‚ BULL' if last_r['Apex_Trend']==1 else 'ğŸ» BEAR'}\nVector: {'â†—ï¸ BULL' if last_r['DarkVector_Trend']==1 else 'â†˜ï¸ BEAR'}\nSqueeze: {'ğŸ’¥ ON' if last_r['Squeeze_On'] else 'ğŸ’¤ OFF'}\n\nğŸ“Š RSI: {last_r['RSI']:.1f}\nğŸ”‹ Vol: {last_r['RVOL']:.1f}x\n\n{macro_text}\n\nğŸ¤– AI Outlook: {ai_verdict}\n\n#Trading #DarkPool #Titan"

                msg = st.text_area("Message Preview", value=signal_text, height=150)

                # FIX: Added File Uploader for Screenshots
                uploaded_file = st.file_uploader("Upload Chart Screenshot (Optional but Recommended)", type=['png', 'jpg', 'jpeg'])

                col_b1, col_b2 = st.columns(2)

                # FIX: Telegram Infinite Split Message Logic & Use Variables from Sidebar
                if col_b1.button("Send to Telegram ğŸš€"):
                    if tg_token and tg_chat:
                        try:
                            # 1. Send Photo if uploaded
                            if uploaded_file:
                                files = {'photo': uploaded_file.getvalue()}
                                url_photo = f"https://api.telegram.org/bot{tg_token}/sendPhoto"
                                data_photo = {'chat_id': tg_chat, 'caption': f"ğŸ”¥ Analysis: {ticker}", 'parse_mode': 'Markdown'}
                                requests.post(url_photo, data=data_photo, files=files)

                            # 2. Send Full Text (Infinite Loop Splitting to avoid 4096 char limit cutoffs)
                            url_msg = f"https://api.telegram.org/bot{tg_token}/sendMessage"

                            # Clean up AI text to look good
                            clean_msg = msg.replace("###", "")

                            # Chunking Loop - Fixed for Markdown Safety
                            # Reducing limit to 2000 chars to be ultra-safe
                            max_length = 2000 

                            if len(clean_msg) <= max_length:
                                data_msg = {"chat_id": tg_chat, "text": clean_msg} # REMOVED parse_mode to avoid cutoff errors
                                requests.post(url_msg, data=data_msg)
                            else:
                                for i in range(0, len(clean_msg), max_length):
                                    chunk = clean_msg[i:i+max_length]
                                    data_msg = {"chat_id": tg_chat, "text": f"(Part {i//max_length + 1}) {chunk}"} # REMOVED parse_mode
                                    requests.post(url_msg, data=data_msg)

                            st.success("âœ… Sent to Telegram (Split into multiple parts to prevent cutoff)!")

                        except Exception as e:
                            st.error(f"Failed: {e}")
                    else:
                        st.warning("âš ï¸ Enter Telegram Keys in Sidebar.")

                if col_b2.button("Post to X (Twitter)"):
                    encoded_msg = urllib.parse.quote(msg)
                    st.link_button("ğŸ¦ Launch Tweet", f"https://twitter.com/intent/tweet?text={encoded_msg}")

        else:
            st.error("Data connection failed. Try another ticker.")


"""
TITAN INTRADAY PRO - MOBILE EDITION
Version 18.1: Touch-Optimized Interface + Vertical AI Analysis Cards
"""

import time
import math
import sqlite3
import random
import json
from typing import Dict, Optional, List
from contextlib import contextmanager

import streamlit as st
import pandas as pd
import numpy as np
import requests
import plotly.graph_objects as go
import streamlit.components.v1 as components
from datetime import datetime, timezone

# =============================================================================
# PAGE CONFIG (Mobile Friendly)
# =============================================================================
st.set_page_config(
    page_title="TITAN MOBILE",
    layout="wide",  # Wide layout allows full width usage on mobile
    page_icon="ğŸ“±",
    initial_sidebar_state="collapsed"  # Collapsed by default for mobile screen space
)

# =============================================================================
# CUSTOM CSS (MOBILE OPTIMIZED)
# =============================================================================
st.markdown("""
<style>
    .main { background-color: #0b0c10; }

    /* Mobile-First Metric Cards */
    div[data-testid="metric-container"] {
        background: rgba(31, 40, 51, 0.9);
        border: 1px solid #45a29e;
        padding: 15px; /* Larger padding for touch */
        border-radius: 12px;
        margin-bottom: 10px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }

    /* Larger Text for Mobile Readability */
    div[data-testid="metric-container"] label {
        font-size: 14px !important;
        color: #c5c6c7 !important;
    }
    div[data-testid="metric-container"] div[data-testid="stMetricValue"] {
        font-size: 24px !important;
        color: #66fcf1 !important;
    }

    h1, h2, h3 {
        font-family: 'Roboto Mono', monospace;
        color: #c5c6c7;
        word-wrap: break-word; /* Prevent overflow */
    }

    /* Touch-Friendly Buttons */
    .stButton > button {
        background: linear-gradient(135deg, #1f2833, #0b0c10);
        border: 1px solid #45a29e;
        color: #66fcf1;
        font-weight: bold;
        height: 3em; /* Taller buttons for thumbs */
        font-size: 16px !important;
        border-radius: 8px;
        margin-top: 5px;
        margin-bottom: 5px;
    }
    .stButton > button:hover {
        background: #45a29e;
        color: #0b0c10;
    }

    /* Report Card Styling for Mobile */
    .report-card {
        background-color: #1f2833;
        border-left: 5px solid #45a29e;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 15px;
    }
    .report-header {
        font-size: 18px;
        font-weight: bold;
        color: #ffffff;
        margin-bottom: 10px;
        border-bottom: 1px solid #45a29e;
        padding-bottom: 5px;
    }
    .report-item {
        margin-bottom: 8px;
        font-size: 14px;
        color: #c5c6c7;
    }
    .highlight { color: #66fcf1; font-weight: bold; }

</style>
""", unsafe_allow_html=True)

# =============================================================================
# CONSTANTS
# =============================================================================
BINANCE_API_BASE = "https://api.binance.us/api/v3"
HEADERS = {"User-Agent": "Mozilla/5.0", "Accept": "application/json"}

# A strong "popular" list to speed selection (still uses original manual Asset input too)
POPULAR_BASES = [
    "BTC", "ETH", "SOL", "XRP", "BNB", "ADA", "DOGE", "LINK", "AVAX", "DOT",
    "MATIC", "LTC", "BCH", "ATOM", "XLM", "ETC", "AAVE", "UNI", "SHIB", "TRX",
    "FIL", "NEAR", "ICP", "ARB", "OP", "SUI", "APT", "INJ", "TIA", "RNDR"
]

# =============================================================================
# TICKER UNIVERSE (AUTO-LOAD FROM BINANCE US)
# =============================================================================
@st.cache_data(ttl=3600)
def get_binanceus_usdt_bases() -> List[str]:
    """
    Pull all Binance US symbols and return unique base assets for USDT pairs.
    This gives you 'lots more tickers' without hardcoding, and stays current.
    """
    try:
        r = requests.get(f"{BINANCE_API_BASE}/exchangeInfo", headers=HEADERS, timeout=6)
        if r.status_code != 200:
            return []
        js = r.json()
        bases = set()
        for s in js.get("symbols", []):
            # Keep spot-trading symbols only (Binance US)
            if s.get("status") != "TRADING":
                continue
            if s.get("quoteAsset") != "USDT":
                continue
            base = s.get("baseAsset")
            if base:
                bases.add(base.upper())
        return sorted(bases)
    except Exception:
        return []

# =============================================================================
# LIVE TICKER WIDGET (Expanded)
# =============================================================================
# Keep the original 3 and add many more, plus include the selected symbol later.
# We'll render this tape once at the top; it remains fast and mobile-friendly.
def render_ticker_tape(selected_symbol: str):
    # Ensure selected_symbol is in proName format for TradingView
    # Keep original "BINANCE:" exchange in the tape exactly as you had it
    # (you can later add a toggle if you want BINANCEUS:)
    base = selected_symbol.replace("USDT", "")
    tape_bases = []
    # Start with original three (no omission)
    tape_bases.extend(["BTC", "ETH", "SOL"])
    # Add a larger popular set
    tape_bases.extend([
        "XRP", "BNB", "ADA", "DOGE", "LINK", "AVAX", "DOT", "MATIC", "LTC", "BCH",
        "ATOM", "XLM", "ETC", "AAVE", "UNI", "SHIB", "TRX", "FIL", "NEAR", "ICP"
    ])
    # Add the currently selected base (so tape always includes what you're watching)
    if base and base not in tape_bases:
        tape_bases.insert(0, base)

    # De-dupe while preserving order
    seen = set()
    tape_bases = [x for x in tape_bases if not (x in seen or seen.add(x))]

    symbols_json = json.dumps(
        [{"proName": f"BINANCE:{b}USDT", "title": b} for b in tape_bases],
        separators=(",", ":")
    )

    components.html(
        f"""
        <div class="tradingview-widget-container">
          <div class="tradingview-widget-container__widget"></div>
          <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-ticker-tape.js" async>
          {{
            "symbols": {symbols_json},
            "showSymbolLogo": true,
            "colorTheme": "dark",
            "isTransparent": true,
            "displayMode": "adaptive",
            "locale": "en"
          }}
          </script>
        </div>
        """,
        height=50
    )

# HEADER with JS Clock (Stacked for Mobile)
st.title("ğŸ’  TITAN MOBILE")
st.caption("v18.1 | AI TRADING ENGINE")

# Mobile Clock
components.html(
    """
    <div id="live_clock"></div>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap');
        body { margin: 0; background-color: transparent; text-align: center; }
        #live_clock {
            font-family: 'Roboto Mono', monospace;
            font-size: 20px;
            color: #39ff14;
            text-shadow: 0 0 10px rgba(57, 255, 20, 0.8);
            font-weight: 800;
            padding: 5px;
        }
    </style>
    <script>
    function updateTime() {
        const now = new Date();
        const timeString = now.toLocaleTimeString('en-GB', { timeZone: 'UTC' });
        document.getElementById('live_clock').innerHTML = 'UTC: ' + timeString;
    }
    setInterval(updateTime, 1000);
    updateTime();
    </script>
    """,
    height=40
)

# =============================================================================
# SIDEBAR (Settings)
# =============================================================================
with st.sidebar:
    st.header("âš™ï¸ CONTROL")
    if st.button("ğŸ”„ REFRESH", use_container_width=True):
        st.rerun()

    st.subheader("ğŸ“¡ FEED")

    # ---- NEW: Load ticker universe (Binance US) ----
    bases_all = get_binanceus_usdt_bases()

    # Session state for original manual asset input (keeps original behavior)
    if "symbol_input" not in st.session_state:
        st.session_state.symbol_input = "BTC"

    # Quick select controls (does NOT remove original input; it feeds it)
    with st.expander("ğŸ§¬ Ticker Universe (Quick Select)", expanded=True):
        if bases_all:
            list_mode = st.selectbox(
                "List",
                ["Popular", "All Binance US (USDT)"],
                index=0
            )

            if list_mode == "Popular":
                options = [b for b in POPULAR_BASES if b in bases_all] or POPULAR_BASES
            else:
                # Put popular first, then everything else
                options = POPULAR_BASES + [b for b in bases_all if b not in POPULAR_BASES]

            quick_base = st.selectbox("Quick Ticker", options, index=(options.index("BTC") if "BTC" in options else 0))
            q1, q2 = st.columns([1, 1])
            with q1:
                if st.button("âœ… Use Quick Ticker", use_container_width=True):
                    st.session_state.symbol_input = quick_base
            with q2:
                st.caption(f"{len(bases_all)} tickers loaded")
        else:
            st.warning("Ticker universe unavailable (Binance US exchangeInfo). Manual input still works.")

    # ---- ORIGINAL manual input kept (no omission) ----
    symbol_input = st.text_input("Asset", value=st.session_state.symbol_input)
    st.session_state.symbol_input = symbol_input  # keep synced
    symbol = symbol_input.strip().upper().replace("/", "").replace("-", "")
    if not symbol.endswith("USDT"):
        symbol += "USDT"

    # Use cols for compact settings
    c1, c2 = st.columns(2)
    with c1:
        timeframe = st.selectbox("TF", ["15m", "1h", "4h", "1d"], index=1)
    with c2:
        limit = st.slider("Depth", 100, 500, 200, 50)

    st.markdown("---")
    st.subheader("ğŸ§  LOGIC")
    amplitude = st.number_input("Amp", 2, 200, 10)
    channel_dev = st.number_input("Dev", 0.5, 10.0, 3.0, 0.1)
    hma_len = st.number_input("HMA", 2, 400, 50)
    gann_len = st.number_input("Gann", 1, 50, 3)

    with st.expander("ğŸ¯ Targets"):
        tp1_r = st.number_input("TP1 (R)", value=1.5)
        tp2_r = st.number_input("TP2 (R)", value=3.0)
        tp3_r = st.number_input("TP3 (R)", value=5.0)

    st.markdown("---")
    st.subheader("ğŸ¤– NOTIFICATIONS")
    tg_token = st.text_input("Bot Token", value=st.secrets.get("TELEGRAM_TOKEN", ""), type="password")
    tg_chat = st.text_input("Chat ID", value=st.secrets.get("TELEGRAM_CHAT_ID", ""))

# Render expanded ticker tape AFTER we know the chosen symbol (keeps original widget concept, expands it)
render_ticker_tape(symbol)

# =============================================================================
# LOGIC ENGINES
# =============================================================================
def calculate_hma(series, length):
    half_len = int(length / 2)
    sqrt_len = int(math.sqrt(length))
    wma_f = series.rolling(length).mean()
    wma_h = series.rolling(half_len).mean()
    diff = 2 * wma_h - wma_f
    return diff.rolling(sqrt_len).mean()

def calculate_fibonacci(df, lookback=50):
    recent = df.iloc[-lookback:]
    h, l = recent['high'].max(), recent['low'].min()
    d = h - l
    fibs = {
        'fib_382': h - (d * 0.382),
        'fib_500': h - (d * 0.500),
        'fib_618': h - (d * 0.618),
        'high': h, 'low': l
    }
    return fibs

def calculate_fear_greed_index(df):
    try:
        df['log_ret'] = np.log(df['close'] / df['close'].shift(1))
        vol_score = 50 - ((df['log_ret'].rolling(30).std().iloc[-1] - df['log_ret'].rolling(90).std().iloc[-1]) / df['log_ret'].rolling(90).std().iloc[-1]) * 100
        vol_score = max(0, min(100, vol_score))
        rsi = df['rsi'].iloc[-1]
        sma_50 = df['close'].rolling(50).mean().iloc[-1]
        dist = (df['close'].iloc[-1] - sma_50) / sma_50
        trend_score = 50 + (dist * 1000)
        fg = (vol_score * 0.3) + (rsi * 0.4) + (max(0, min(100, trend_score)) * 0.3)
        return int(fg)
    except:
        return 50

def run_backtest(df, tp1_r):
    trades = []
    signals = df[(df['buy']) | (df['sell'])]
    for idx, row in signals.iterrows():
        future = df.loc[idx+1: idx+20]
        if future.empty:
            continue
        entry = row['close']; stop = row['entry_stop']; tp1 = row['tp1']; is_long = row['is_bull']
        outcome = "PENDING"; pnl = 0
        if is_long:
            if future['high'].max() >= tp1:
                outcome = "WIN"; pnl = abs(entry - stop) * tp1_r
            elif future['low'].min() <= stop:
                outcome = "LOSS"; pnl = -abs(entry - stop)
        else:
            if future['low'].min() <= tp1:
                outcome = "WIN"; pnl = abs(entry - stop) * tp1_r
            elif future['high'].max() >= stop:
                outcome = "LOSS"; pnl = -abs(entry - stop)
        if outcome != "PENDING":
            trades.append({'outcome': outcome, 'pnl': pnl})

    if not trades:
        return 0, 0, 0
    df_res = pd.DataFrame(trades)
    total = len(df_res)
    win_rate = (len(df_res[df_res['outcome'] == 'WIN']) / total) * 100
    net_r = (len(df_res[df_res['outcome'] == 'WIN']) * tp1_r) - len(df_res[df_res['outcome'] == 'LOSS'])
    return total, win_rate, net_r

# --- MOBILE OPTIMIZED REPORT GENERATOR ---
# Uses HTML/CSS Cards instead of Wide Tables
def generate_mobile_report(row, symbol, tf, fibs, fg_index, smart_stop):
    is_bull = row['is_bull']
    direction = "LONG ğŸ‚" if is_bull else "SHORT ğŸ»"

    # Logic
    titan_sig = 1 if row['is_bull'] else -1
    apex_sig = row['apex_trend']
    gann_sig = row['gann_trend']

    score_val = 0
    if titan_sig == apex_sig: score_val += 1
    if titan_sig == gann_sig: score_val += 1

    confidence = "LOW"
    if score_val == 2: confidence = "MAX ğŸ”¥"
    elif score_val == 1: confidence = "HIGH"

    vol_desc = "Normal"
    if row['rvol'] > 2.0: vol_desc = "IGNITION ğŸš€"

    squeeze_txt = "âš ï¸ SQUEEZE ACTIVE" if row['in_squeeze'] else "âšª NO SQUEEZE"

    # HTML Card Construction
    report_html = f"""
    <div class="report-card">
        <div class="report-header">ğŸ’  SIGNAL: {direction}</div>
        <div class="report-item">Confidence: <span class="highlight">{confidence}</span></div>
        <div class="report-item">Sentiment: <span class="highlight">{fg_index}/100</span></div>
        <div class="report-item">Squeeze: <span class="highlight">{squeeze_txt}</span></div>
    </div>

    <div class="report-card">
        <div class="report-header">ğŸŒŠ FLOW & VOL</div>
        <div class="report-item">RVOL: <span class="highlight">{row['rvol']:.2f} ({vol_desc})</span></div>
        <div class="report-item">Money Flow: <span class="highlight">{row['money_flow']:.2f}</span></div>
        <div class="report-item">VWAP Relation: <span class="highlight">{'Above' if row['close'] > row['vwap'] else 'Below'}</span></div>
    </div>

    <div class="report-card">
        <div class="report-header">ğŸ¯ EXECUTION PLAN</div>
        <div class="report-item">Entry: <span class="highlight">{row['close']:.4f}</span></div>
        <div class="report-item">ğŸ›‘ SMART STOP: <span class="highlight">{smart_stop:.4f}</span></div>
        <div class="report-item">1ï¸âƒ£ TP1 (1.5R): <span class="highlight">{row['tp1']:.4f}</span></div>
        <div class="report-item">2ï¸âƒ£ TP2 (3.0R): <span class="highlight">{row['tp2']:.4f}</span></div>
        <div class="report-item">3ï¸âƒ£ TP3 (5.0R): <span class="highlight">{row['tp3']:.4f}</span></div>
    </div>
    """
    return report_html

def send_telegram_msg(token, chat, msg):
    if not token or not chat:
        return False
    try:
        r = requests.post(
            f"https://api.telegram.org/bot{token}/sendMessage",
            json={"chat_id": chat, "text": msg, "parse_mode": "Markdown"},
            timeout=5
        )
        return r.status_code == 200
    except:
        return False

@st.cache_data(ttl=5)
def get_klines(symbol_bin, interval, limit):
    try:
        r = requests.get(
            f"{BINANCE_API_BASE}/klines",
            params={"symbol": symbol_bin, "interval": interval, "limit": limit},
            headers=HEADERS,
            timeout=4
        )
        if r.status_code == 200:
            df = pd.DataFrame(r.json(), columns=['t','o','h','l','c','v','T','q','n','V','Q','B'])
            df['timestamp'] = pd.to_datetime(df['t'], unit='ms')
            df[['open','high','low','close','volume']] = df[['o','h','l','c','v']].astype(float)
            return df[['timestamp','open','high','low','close','volume']]
    except:
        pass
    return pd.DataFrame()

def run_engines(df, amp, dev, hma_l, tp1, tp2, tp3, mf_l, vol_l, gann_l):
    if df.empty:
        return df
    df = df.copy().reset_index(drop=True)

    # Indicators
    df['tr'] = np.maximum(
        df['high']-df['low'],
        np.maximum(abs(df['high']-df['close'].shift(1)), abs(df['low']-df['close'].shift(1)))
    )
    df['atr'] = df['tr'].ewm(alpha=1/14, adjust=False).mean()
    df['hma'] = calculate_hma(df['close'], hma_l)

    # VWAP
    df['tp'] = (df['high'] + df['low'] + df['close']) / 3
    df['vol_tp'] = df['tp'] * df['volume']
    df['vwap'] = df['vol_tp'].cumsum() / df['volume'].cumsum()

    # Squeeze
    bb_basis = df['close'].rolling(20).mean()
    bb_dev = df['close'].rolling(20).std() * 2.0
    kc_basis = df['close'].rolling(20).mean()
    kc_dev = df['atr'] * 1.5
    df['in_squeeze'] = ((bb_basis - bb_dev) > (kc_basis - kc_dev)) & ((bb_basis + bb_dev) < (kc_basis + kc_dev))

    # Momentum
    delta = df['close'].diff()
    gain = delta.clip(lower=0).ewm(alpha=1/14).mean()
    loss = -delta.clip(upper=0).ewm(alpha=1/14).mean()
    df['rsi'] = 100 - (100 / (1 + (gain/loss)))
    df['rvol'] = df['volume'] / df['volume'].rolling(vol_l).mean()

    # Money Flow
    rsi_source = df['rsi'] - 50
    vol_sma = df['volume'].rolling(mf_l).mean()
    df['money_flow'] = (rsi_source * (df['volume'] / vol_sma)).ewm(span=3).mean()

    pc = df['close'].diff()
    ds_pc = pc.ewm(span=25).mean().ewm(span=13).mean()
    ds_abs_pc = abs(pc).ewm(span=25).mean().ewm(span=13).mean()
    df['hyper_wave'] = (100 * (ds_pc / ds_abs_pc)) / 2

    # Titan Trend
    df['ll'] = df['low'].rolling(amp).min()
    df['hh'] = df['high'].rolling(amp).max()
    trend = np.zeros(len(df))
    stop = np.full(len(df), np.nan)
    curr_t = 0
    curr_s = np.nan
    for i in range(amp, len(df)):
        c = df.at[i,'close']
        d = df.at[i,'atr']*dev
        if curr_t == 0:
            s = df.at[i,'ll'] + d
            curr_s = max(curr_s, s) if not np.isnan(curr_s) else s
            if c < curr_s:
                curr_t = 1
                curr_s = df.at[i,'hh'] - d
        else:
            s = df.at[i,'hh'] - d
            curr_s = min(curr_s, s) if not np.isnan(curr_s) else s
            if c > curr_s:
                curr_t = 0
                curr_s = df.at[i,'ll'] + d
        trend[i] = curr_t
        stop[i] = curr_s

    df['is_bull'] = trend == 0
    df['entry_stop'] = stop

    # Signals
    cond_buy = (df['is_bull']) & (~df['is_bull'].shift(1).fillna(False)) & (df['rvol']>1.0)
    cond_sell = (~df['is_bull']) & (df['is_bull'].shift(1).fillna(True)) & (df['rvol']>1.0)
    df['buy'] = cond_buy
    df['sell'] = cond_sell

    # Targets
    df['sig_id'] = (df['buy']|df['sell']).cumsum()
    df['entry'] = df.groupby('sig_id')['close'].ffill()
    df['stop_val'] = df.groupby('sig_id')['entry_stop'].ffill()
    risk = abs(df['entry'] - df['stop_val'])
    df['tp1'] = np.where(df['is_bull'], df['entry']+(risk*tp1), df['entry']-(risk*tp1))
    df['tp2'] = np.where(df['is_bull'], df['entry']+(risk*tp2), df['entry']-(risk*tp2))
    df['tp3'] = np.where(df['is_bull'], df['entry']+(risk*tp3), df['entry']-(risk*tp3))

    # Apex & Gann
    apex_base = calculate_hma(df['close'], 55)
    apex_atr = df['atr'] * 1.5
    df['apex_upper'] = apex_base + apex_atr
    df['apex_lower'] = apex_base - apex_atr
    apex_t = np.zeros(len(df))
    for i in range(1, len(df)):
        if df.at[i, 'close'] > df.at[i, 'apex_upper']:
            apex_t[i] = 1
        elif df.at[i, 'close'] < df.at[i, 'apex_lower']:
            apex_t[i] = -1
        else:
            apex_t[i] = apex_t[i-1]
    df['apex_trend'] = apex_t

    sma_h = df['high'].rolling(gann_l).mean()
    sma_l = df['low'].rolling(gann_l).mean()
    g_trend = np.full(len(df), np.nan)
    g_act = np.full(len(df), np.nan)
    curr_g_t = 1
    curr_g_a = sma_l.iloc[gann_l] if len(sma_l) > gann_l else np.nan
    for i in range(gann_l, len(df)):
        c = df.at[i,'close']
        h_ma = sma_h.iloc[i]
        l_ma = sma_l.iloc[i]
        prev_a = g_act[i-1] if (i>0 and not np.isnan(g_act[i-1])) else curr_g_a
        if curr_g_t == 1:
            if c < prev_a:
                curr_g_t = -1
                curr_g_a = h_ma
            else:
                curr_g_a = l_ma
        else:
            if c > prev_a:
                curr_g_t = 1
                curr_g_a = l_ma
            else:
                curr_g_a = h_ma
        g_trend[i] = curr_g_t
        g_act[i] = curr_g_a
    df['gann_trend'] = g_trend
    df['gann_act'] = g_act

    return df

# =============================================================================
# APP MAIN
# =============================================================================
df = get_klines(symbol, timeframe, limit)

if not df.empty:
    df = df.dropna(subset=['close'])
    df = run_engines(df, int(amplitude), channel_dev, int(hma_len), tp1_r, tp2_r, tp3_r, 14, 20, int(gann_len))

    last = df.iloc[-1]
    fibs = calculate_fibonacci(df)
    fg_index = calculate_fear_greed_index(df)

    if last['is_bull']:
        smart_stop = min(last['entry_stop'], fibs['fib_618'] * 0.9995)
    else:
        smart_stop = max(last['entry_stop'], fibs['fib_618'] * 1.0005)

    # ----------------------------------------------------
    # MOBILE METRICS (2x2 Grid instead of 1x4)
    # ----------------------------------------------------
    # Row 1: Price Widget + Trend
    c_m1, c_m2 = st.columns(2)
    with c_m1:
        # TradingView Widget customized for mobile height
        tv_symbol = f"BINANCE:{symbol}"
        components.html(f"""
        <div class="tradingview-widget-container">
          <div class="tradingview-widget-container__widget"></div>
          <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-single-quote.js" async>
          {{ "symbol": "{tv_symbol}", "width": "100%", "colorTheme": "dark", "isTransparent": true, "locale": "en" }}
          </script>
        </div>
        """, height=120)
    with c_m2:
        st.metric("TREND", "BULL ğŸ‚" if last['gann_trend'] == 1 else "BEAR ğŸ»")

    # Row 2: Stops & Targets
    c_m3, c_m4 = st.columns(2)
    with c_m3:
        st.metric("STOP", f"{smart_stop:.2f}")
    with c_m4:
        st.metric("TP3", f"{last['tp3']:.2f}")

    # ----------------------------------------------------
    # REPORT & ACTIONS (Stacked for Mobile)
    # ----------------------------------------------------
    report_html = generate_mobile_report(last, symbol, timeframe, fibs, fg_index, smart_stop)

    # Display the HTML Report Card directly
    st.markdown(report_html, unsafe_allow_html=True)

    # Action Buttons (Full width for easy tapping)
    st.markdown("### âš¡ ACTION")

    # Button Grid
    b_col1, b_col2 = st.columns(2)
    with b_col1:
        if st.button("ğŸ”¥ ALERT TG", use_container_width=True):
            msg = f"TITAN SIGNAL: {symbol} | {'LONG' if last['is_bull'] else 'SHORT'} | EP: {last['close']}"
            if send_telegram_msg(tg_token, tg_chat, msg):
                st.success("SENT")
            else:
                st.error("FAIL")

    with b_col2:
        if st.button("ğŸ“ REPORT TG", use_container_width=True):
            # Strip HTML for Telegram (keeps your original idea; simple transform)
            txt_rep = report_html.replace("<br>", "\n").replace("<div>", "").replace("</div>", "\n")
            if send_telegram_msg(tg_token, tg_chat, f"REPORT: {symbol}\n{txt_rep}",):
                st.success("SENT")
            else:
                st.error("FAIL")

    # Backtest Mini-Stat
    b_total, b_win, b_net = run_backtest(df, tp1_r)
    st.caption(f"ğŸ“Š Live Stats: {b_win:.1f}% Win Rate | {b_net:.1f}R Net ({b_total} Trades)")

    # ----------------------------------------------------
    # MAIN CHART (Reduced Height for Mobile)
    # ----------------------------------------------------
    fig = go.Figure()
    fig.add_candlestick(x=df['timestamp'], open=df['open'], high=df['high'], low=df['low'], close=df['close'], name='Price')
    fig.add_trace(go.Scatter(x=df['timestamp'], y=df['hma'], mode='lines', name='HMA', line=dict(color='#66fcf1', width=1)))
    fig.add_trace(go.Scatter(x=df['timestamp'], y=df['vwap'], mode='lines', name='VWAP', line=dict(color='#9933ff', width=2)))

    buys = df[df['buy']]
    sells = df[df['sell']]
    if not buys.empty:
        fig.add_trace(go.Scatter(x=buys['timestamp'], y=buys['low'], mode='markers',
                                 marker=dict(symbol='triangle-up', size=10, color='#00ff00'), name='BUY'))
    if not sells.empty:
        fig.add_trace(go.Scatter(x=sells['timestamp'], y=sells['high'], mode='markers',
                                 marker=dict(symbol='triangle-down', size=10, color='#ff0000'), name='SELL'))

    # Mobile Specific Layout: Fixed Height, Minimal Margins
    fig.update_layout(height=400, template='plotly_dark', margin=dict(l=0, r=0, t=20, b=20),
                      xaxis_rangeslider_visible=False, legend=dict(orientation="h", y=1, x=0))
    st.plotly_chart(fig, use_container_width=True)

    # ----------------------------------------------------
    # INDICATORS (Tabs)
    # ----------------------------------------------------
    t1, t2, t3 = st.tabs(["ğŸ“Š GANN", "ğŸŒŠ FLOW", "ğŸ§  SENT"])

    with t1:
        f1 = go.Figure()
        f1.add_candlestick(x=df['timestamp'], open=df['open'], high=df['high'], low=df['low'], close=df['close'])
        df_g = df.dropna(subset=['gann_act'])
        f1.add_trace(go.Scatter(
            x=df_g['timestamp'],
            y=df_g['gann_act'],
            mode='markers',
            marker=dict(color=np.where(df_g['gann_trend'] == 1, '#00ff00', '#ff0000'), size=3)
        ))
        f1.update_layout(height=300, template='plotly_dark', margin=dict(l=0, r=0, t=0, b=0))
        st.plotly_chart(f1, use_container_width=True)

    with t2:
        f2 = go.Figure()
        cols = ['#00e676' if x > 0 else '#ff1744' for x in df['money_flow']]
        f2.add_trace(go.Bar(x=df['timestamp'], y=df['money_flow'], marker_color=cols))
        f2.update_layout(height=300, template='plotly_dark', margin=dict(l=0, r=0, t=0, b=0))
        st.plotly_chart(f2, use_container_width=True)

    with t3:
        f3 = go.Figure(go.Indicator(
            mode="gauge+number",
            value=fg_index,
            gauge={
                'axis': {'range': [None, 100]},
                'bar': {'color': "white"},
                'steps': [
                    {'range': [0, 25], 'color': '#ff1744'},
                    {'range': [75, 100], 'color': '#00b0ff'}
                ]
            }
        ))
        f3.update_layout(height=250, template='plotly_dark', margin=dict(l=20, r=20, t=30, b=0))
        st.plotly_chart(f3, use_container_width=True)
else:
    st.error("No data returned. Check ticker, timeframe, or Binance US availability.")





</ Code_Provided>


  </Constraints>

<Output_Standard>
<Response_Format>
You must output exactly three sections, in this order:
1) PYTHON FILE (full content): a single code block labeled as app.py
2) TEXT FILE (full content): a single code block labeled as indicators.txt (the user-provided content, preserved verbatim; if you transform it, include BOTH original and transformed versions clearly labeled without deleting anything)
3) EVALUATION REPORT: a structured report (markdown) covering implementation checklist, gaps, configuration steps, translation coverage, and limitations.
</Response_Format>

```
<Code_Block_Requirements>
  - Use fenced code blocks.
  - Do not truncate code.
  - Ensure the .py code is directly runnable as a Streamlit app (streamlit run app.py).
</Code_Block_Requirements>
```

</Output_Standard>

<Source_Citation></Source_Citation>
</optimized_prompt>
