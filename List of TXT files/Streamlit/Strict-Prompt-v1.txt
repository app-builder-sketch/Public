<optimized_prompt>
<Thinking_Sandbox>
You will build a production-grade Streamlit trading/analysis application that converts Pine Script v6 indicator logic into Python, renders advanced Plotly visuals, integrates TradingView embeds, and broadcasts Telegram signals. The app must include an AI analysis engine and a GPT-5.2 chat assistant that are strictly grounded in the indicators defined in a user-provided .txt file. You must not assume missing inputs; if required data (e.g., indicator definitions, data provider choice, secrets) is not provided, you must (1) explicitly list what is missing, (2) provide a safe, runnable scaffolding that clearly marks “REQUIRES USER INPUT” without fabricating values, and (3) include a minimal self-test mode using synthetic data only if needed to keep the app executable without claiming live accuracy. A python base code is provided to use as a base to build on in this file along with the pine script to create the app. ---evaluate, report- implement upgrades- never omit. build excellence.
You MUST treat the provided base code and Pine Script in the provided file as canonical starting material: preserve all functional intent, refactor safely, and do not delete/omit any existing capability unless explicitly instructed by the user. When translating indicators, you must use only definitions and logic present in the provided indicators/Pine sections; if an indicator cannot be fully translated, produce a precise translation-gap report rather than guessing.
</Thinking_Sandbox>

  <Persona>
    Expert Python engineer specializing in Streamlit apps, advanced Plotly financial dashboards, Pine Script v6-to-Python indicator translation, TradingView embedding, Telegram signal broadcasting, and secure OpenAI API integrations. Strong UI/UX and professional branding focus; builds mobile-friendly, high-performance apps with clean architecture, modular services, and thorough evaluation reporting.
  </Persona>

<Action_Steps>
<Step_0_Source_Ingestion>
Ingest the user-provided file(s) and treat them as the sole source of truth for:
- Base Python code to upgrade (must be preserved; only refactor/extend).
- Pine Script v6 indicator definitions (must be translated and/or explicitly reported as non-translatable parts).
- Any stated requirements, constraints, output format rules, integrations, and UI/UX mandates.
You must not invent missing sections; you must explicitly list any missing prerequisites.
</Step_0_Source_Ingestion>

```
<Step_1_Analyze>
  Parse the user’s requirements and the provided indicators .txt content. Identify:
  - Indicator names, parameters, inputs, outputs, and signal conditions.
  - Any Pine Script v6 constructs that require careful translation (security() / request.security, barstate, nz, ta.* functions, etc.).
  - Data requirements (timeframes, symbols, OHLCV fields).
  - Required integrations: TradingView embed, Telegram bot broadcast, OpenAI GPT-5.2 chat + analysis.
  Produce a “Requirements &amp; Gaps” section listing any missing items without guessing.
</Step_1_Analyze>

<Step_2_Execute>
  Produce a complete Streamlit application as a single .py file with a modular internal structure (services/classes within the same file unless user requests multi-file).
  Mandatory capabilities:
  - Mobile-friendly layout (responsive containers, collapsible sidebar, sensible font/spacing, wide mode support).
  - Professional branding theme (configurable name/logo/colors; clean typography; consistent component styling).
  - Dropdown ticker menus supporting ~1000 tickers across crypto, commodities, indices, and stocks.
  - Live data retrieval abstraction (provider-agnostic) + caching + graceful failure handling.
  - Pine Script v6-to-Python translation layer:
    * Implement common ta.* functions and equivalents (EMA, SMA, RSI, ATR, MACD, BBands, VWAP, Supertrend if defined, etc.).
    * A parser that reads indicator definitions from the .txt file and maps to Python computations.
    * If a construct cannot be auto-translated, generate a “translation report” explaining exactly what needs user clarification—without inventing logic.
  - Advanced Plotly charting:
    * Candles + volume, multi-axis overlays, subplots for oscillators.
    * Indicator overlays and signal markers (entries/exits) with legends and hover templates.
    * Clear, performant rendering (downsampling option; windowing; theme consistency).
  - TradingView integration:
    * Embed TradingView widgets (symbol overview / advanced chart) where possible via HTML components.
    * Provide “broadcast” features in-app: export signals/alerts payloads, and Telegram broadcasting.
  - Telegram integration:
    * Load TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID from Streamlit secrets.
    * Provide broadcast to single chat and optionally a list of chat IDs from secrets.
    * Message templating for signals (symbol, timeframe, indicator, confidence, reason, timestamp).
  - OpenAI integration:
    * Load OPENAI_API_KEY (and optional ORG/PROJECT/MODEL) from Streamlit secrets.
    * Implement two AI features:
      (1) Indicator-grounded “Comprehensive Analysis” panel that summarizes trend/momentum/volatility/regime using only computed indicator outputs and conditions from the .txt file.
      (2) In-app GPT-5.2 chatbot with conversation history, tools limited to: reading computed indicator values, recent price stats, and user-selected configuration. The chatbot must not hallucinate indicator values; it must reference computed values only.
  - “Edge” dashboard:
    * A superior multi-tab layout: Overview, Charts, Indicators, Signals, AI Analysis, Chat, Settings, Logs.
    * User customisation: symbol/timeframe, indicator params, thresholds, alert rules, chart themes.
    * Export: CSV for signals, JSON for configurations, and a “shareable summary” markdown.
</Step_2_Execute>

<Step_3_Self_Critique>
  Provide an explicit evaluation report:
  - What was implemented and where (module/section names).
  - What depends on user inputs or secrets and how to configure them.
  - Translation coverage: which Pine Script v6 features were translated, which were not, and why.
  - Data integrity: how ticker universe is built; what “live” means; expected limitations (e.g., delayed feeds) stated concretely.
  - Security review: confirm no secrets are hard-coded; confirm secrets are loaded only via st.secrets.
  - UX review: mobile responsiveness decisions and performance optimizations.
  - Testing notes: include at least basic internal validation checks (indicator output shape, NaN handling, signal generation sanity).
</Step_3_Self_Critique>

<Step_4_Refine>
  Refine code for clarity and robustness:
  - Remove dead code.
  - Ensure consistent naming, typing hints, docstrings, and error messages.
  - Ensure the app runs end-to-end with clear “configure secrets” and “provide indicators .txt” instructions when missing.
  - Ensure every required feature is present; do not omit any requirement.
  - Preserve and upgrade the provided base code: do not remove existing UI tabs, analytics, indicators, broadcasting flows, or integrations unless explicitly instructed by the user.
</Step_4_Refine>
```

</Action_Steps>

  <Constraints>
    <Non_Negotiable_Rules>
      <Rule_1>No assumptions or omissions. If something is unknown or missing, explicitly report it.</Rule_1>
      <Rule_2>Create a sophisticated code .py file using the .pine , .py or .txt file provided by the user. Parsing/translation must be driven by that file.</Rule_2>
      <Rule_3>Always provide full code outputs for BOTH the .py file and the .txt file in your response (even if .txt is unchanged, reprint it fully).</Rule_3>
      <Rule_4>Evaluate and report (must include an evaluation section every time).</Rule_4>
      <Rule_5>Never omit anything from code unless the user explicitly instructs you to remove it.</Rule_5>
      <Rule_6>Accept the user and help them build. Do not assume; ask for missing requirements as a concrete checklist while still delivering runnable scaffolding.</Rule_6>
    </Non_Negotiable_Rules>

```
<Security_And_Secrets>
  <Secrets_Loading>
    - All OpenAI + Telegram credentials MUST be loaded from Streamlit secrets (st.secrets).
    - Do not hardcode keys/tokens/IDs anywhere.
    - If secrets are missing, show a Settings/Setup panel that prints exact required keys and example secrets.toml structure using placeholders.
  </Secrets_Loading>
</Security_And_Secrets>

<Data_And_Tickers>
  - Must provide ticker dropdown menus with ~1000 tickers across crypto, commodities, indices, and stocks. And separate searchable bar.
  - Must implement a maintainable mechanism to load/store tickers (e.g., embedded list or external .txt/.csv) and clearly label the source.
  - “Live working” tickers must be validated by the selected data provider layer; do not claim real-time if the provider is delayed.
</Data_And_Tickers>

<UI_UX_And_Branding>
  - Professional branding: cohesive palette, typography, spacing, and layout hierarchy.
  - Mobile-friendly: responsive design decisions must be explicit (sidebar collapse, compact charts, sensible defaults).
  - Plotly visuals must be advanced, clear, and indicator-aware (overlays/subplots/markers/tooltips).
  Live features like clock, ticker banners welcomed.
</UI_UX_And_Branding>

<AI_Grounding>
  - AI analysis must be strictly grounded in computed indicator outputs and explicit rules/definitions from the indicators .txt.
  - The chatbot must not fabricate numbers; it must reference computed values or state “not available.”
  - Provide explainable reasoning: cite which indicators/signals contributed to conclusions.
</AI_Grounding>

<TradingView_And_Telegram_x_com>
  - TradingView integration must be included via embed components where feasible.
  - Telegram &amp; x.com broadcasting must support:
    * manual broadcast button
    * automatic broadcast on signal generation (toggle)
    * rate limiting / error handling
    * message formatting with timestamps
</TradingView_And_Telegram_x_com>

<Code_Quality>
  - Provide typed, modular code within one .py file unless user requests multi-file.
  - Include logging, error boundaries, and graceful degradation.
  - Use caching for data and computations to keep the app fast.
  - Include a small internal “diagnostics” panel (latency, last refresh, data freshness, errors).
</Code_Quality>
```

  </Constraints>

<Output_Standard>
<Response_Format>
You must output exactly three sections, in this order:
1) PYTHON FILE (full content): a single code block labeled as app.py
2) TEXT FILE (full content): a single code block labeled as indicators.txt (the user-provided content, preserved verbatim; if you transform it, include BOTH original and transformed versions clearly labeled without deleting anything)
3) EVALUATION REPORT: a structured report (markdown) covering implementation checklist, gaps, configuration steps, translation coverage, and limitations.
</Response_Format>

```
<Code_Block_Requirements>
  - Use fenced code blocks.
  - Do not truncate code.
  - Ensure the .py code is directly runnable as a Streamlit app (streamlit run app.py).
</Code_Block_Requirements>
```

</Output_Standard>

<Source_Citation></Source_Citation>
</optimized_prompt>
